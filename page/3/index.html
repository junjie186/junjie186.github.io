<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>Hexo</title>

    <meta name="description" content="Hexo">
    <meta name="keywords" content="">

    



    <meta property="og:type" content="website"/>
    <meta property="og:title" content=""/>
    <meta property="og:description" content=""/>
    <meta property="og:locale" content="cn" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="http://example.com/page/3/index.html" />
    <meta property="og:site_name" content="John Doe" />
    <meta property="article:publisher" content="" />
    <script type="application/ld+json">
        {
            "@context": "https://schema.org",
            "@type": "WebPage",
            "name": "",
            "description": "",
            "publisher": {
                "@type": "Organization",
                "name": "John Doe"
            },
        }
    </script>


    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1654266144177.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1654266144177.css">


    <script>
        window.isPost = false
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/avatar.jpg" alt="John Doe">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>Hexo</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="index">
  
    
      <article
id="post-算法-day-35"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/20/%E7%AE%97%E6%B3%95-day-35/">算法 | day 35</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h2><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p>
<p>注意，一开始你手头没有任何零钱。</p>
<p>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：bills = [5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。
</code></pre>
<p>思路:很简单,注意收20块时先考虑用一张10块和一张5块,再考虑用3张5块.</p>
<pre><code class="C++">class Solution &#123;
public:
    bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123;
        int nums5=0;
        int nums10=0;
        for(int i=0;i&lt;bills.size();i++)&#123;
            if(bills[i]==5)&#123;
                nums5+=1;
            &#125;else if(bills[i]==10)&#123;
                if(nums5==0)&#123;
                    return false;
                &#125;
                nums5-=1;
                nums10+=1;
            &#125;else&#123;
                if(nums5==0||(nums10==0&amp;&amp;nums5&lt;3))&#123;
                    return false;
                &#125;else if(nums10&gt;0)&#123;
                    nums10-=1;
                    nums5-=1;
                &#125;else&#123;
                    nums5-=3;
                &#125;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;
</code></pre>
<h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p>
<p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
</code></pre>
<p>思路:先按身高从大到小,身高相同时先排第二项较小的顺序对数组进行排序,再按招排序的顺序重新建立新数组,即第二项为几就插入第几个位置,因为是按照身高从大到小进行排序的,新数组已插入的元素一定比后插入的元素大,后插的元素位置一定正确.</p>
<pre><code class="C++">class Solution &#123;
public:
    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;
        if (a[0] == b[0]) return a[1] &lt; b[1];
        return a[0] &gt; b[0];
    &#125;
    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;
        sort (people.begin(), people.end(), cmp);
        vector&lt;vector&lt;int&gt;&gt; que;
        for (int i = 0; i &lt; people.size(); i++) &#123;
            int position = people[i][1];
            que.insert(que.begin() + position, people[i]);
        &#125;
        return que;
    &#125;
&#125;;
</code></pre>
<p>但使用vector是非常费时的，C++中vector（可以理解是一个动态数组，底层是普通数组实现的）如果插入元素大于预先普通数组大小，vector底部会有一个扩容的操作，即申请两倍于原先普通数组的大小，然后把数据拷贝到另一个更大的数组上。</p>
<p>所以使用vector（动态数组）来insert，是费时的，插入再拷贝的话，单纯一个插入的操作就是O(n^2)了，甚至可能拷贝好几次，就不止O(n^2)了。</p>
<p>改成链表之后，C++代码如下：</p>
<pre><code class="bash">class Solution &#123;
public:
    // 身高从大到小排（身高相同k小的站前面）
    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;
        if (a[0] == b[0]) return a[1] &lt; b[1];
        return a[0] &gt; b[0];
    &#125;
    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;
        sort (people.begin(), people.end(), cmp);
        list&lt;vector&lt;int&gt;&gt; que; // list底层是链表实现，插入效率比vector高的多
        for (int i = 0; i &lt; people.size(); i++) &#123;
            int position = people[i][1]; // 插入到下标为position的位置
            std::list&lt;vector&lt;int&gt;&gt;::iterator it = que.begin();
            while (position--) &#123; // 寻找在插入位置
                it++;
            &#125;
            que.insert(it, people[i]);
        &#125;
        return vector&lt;vector&lt;int&gt;&gt;(que.begin(), que.end());
    &#125;
&#125;;
</code></pre>
<h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h2><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。</p>
<p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。
</code></pre>
<p>思路:先按左边位置从小到大排序,然后一直更新重合区间.</p>
<pre><code class="C++">class Solution &#123;
    static bool comp(vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;
        if(a[0]==b[0])&#123;
            return a[1]&lt;b[1];
        &#125;
        return a[0]&lt;b[0];
    &#125;
public:
    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;
        sort(points.begin(),points.end(),comp);
        vector&lt;int&gt; tmp=points[0];
        int num=0;
        for(int i=1;i&lt;points.size();i++)&#123;
            if(tmp[1]&gt;=points[i][0]&amp;&amp;tmp[1]&lt;=points[i][1])&#123;
                tmp=&#123;points[i][0],tmp[1]&#125;;
            &#125;else if(tmp[1]&gt;=points[i][0]&amp;&amp;tmp[1]&gt;points[i][1])&#123;
                tmp=&#123;points[i][0],points[i][1]&#125;;
            &#125;else&#123;
                num++;
                tmp=points[i];
            &#125;
        &#125;
        num++;
        return num;
    &#125;
&#125;;
</code></pre>
<p>注意comp函数应为 <code>static bool</code> 参数应为 <code>const vector&lt;int&gt;&amp;</code></p>
<p>也可以不使用额外空间:</p>
<pre><code class="C++">class Solution &#123;
private:
    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;
        return a[0] &lt; b[0];
    &#125;
public:
    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;
        if (points.size() == 0) return 0;
        sort(points.begin(), points.end(), cmp);

        int result = 1; // points 不为空至少需要一支箭
        for (int i = 1; i &lt; points.size(); i++) &#123;
            if (points[i][0] &gt; points[i - 1][1]) &#123;  // 气球i和气球i-1不挨着，注意这里不是&gt;=
                result++; // 需要一支箭
            &#125;
            else &#123;  // 气球i和气球i-1挨着
                points[i][1] = min(points[i - 1][1], points[i][1]); // 更新重叠气球最小右边界
            &#125;
        &#125;
        return result;
    &#125;
&#125;;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-20T10:18:16.000Z" itemprop="datePublished">2023-04-20</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-29"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/12/%E7%AE%97%E6%B3%95-day-29/">算法 | day 29</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。</p>
<p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
</code></pre>
<p>示例 2：</p>
<pre><code class="bash">输入：nums = [4,4,3,2,1]
输出：[[4,4]]
</code></pre>
<p>没想出来….</p>
<p>例子:</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) &#123;
        if (path.size() &gt; 1) &#123;
            result.push_back(path);
            // 注意这里不要加return，要取树上的节点
        &#125;
        unordered_set&lt;int&gt; uset; // 使用set对本层元素进行去重
        for (int i = startIndex; i &lt; nums.size(); i++) &#123;
            if ((!path.empty() &amp;&amp; nums[i] &lt; path.back())
                    || uset.find(nums[i]) != uset.end()) &#123;
                    continue;
            &#125;
            uset.insert(nums[i]); // 记录这个元素在本层用过了，本层后面不能再用了
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        &#125;
    &#125;
public:
    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;
        result.clear();
        path.clear();
        backtracking(nums, 0);
        return result;
    &#125;
&#125;;
</code></pre>
<p>优化 使用数组来做哈希:</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) &#123;
        if (path.size() &gt; 1) &#123;
            result.push_back(path);
        &#125;
        int used[201] = &#123;0&#125;; // 这里使用数组来进行去重操作，题目说数值范围[-100, 100]
        for (int i = startIndex; i &lt; nums.size(); i++) &#123;
            if ((!path.empty() &amp;&amp; nums[i] &lt; path.back())
                    || used[nums[i] + 100] == 1) &#123;
                    continue;
            &#125;
            used[nums[i] + 100] = 1; // 记录这个元素在本层用过了，本层后面不能再用了
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        &#125;
    &#125;
public:
    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;
        result.clear();
        path.clear();
        backtracking(nums, 0);
        return result;
    &#125;
&#125;;
</code></pre>
<p>我写的错误代码:</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
public:
    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;int&gt; path;
        backtracking(nums,0,path);
        return result;
    &#125;

    void backtracking(vector&lt;int&gt;&amp; nums,int start,vector&lt;int&gt;&amp; path)&#123;
        unordered_set&lt;int&gt; used;
        for(int i=start;i&lt;nums.size();i++)&#123;
            if(!used.empty()&amp;&amp;used.find(nums[i])!=used.end())&#123;
                continue;
            &#125;
            if(path.empty())&#123;
                path.push_back(nums[i]);
                backtracking(nums,i+1,path);
                path.pop_back();
            &#125;else if(nums[i]&gt;=path.back())&#123;
                path.push_back(nums[i]);
                result.push_back(path);
                backtracking(nums,i+1,path);
                path.pop_back();
            &#125;else&#123;
                path.clear();
                path.push_back(nums[i]);
                backtracking(nums,i+1,path);
                path.pop_back();
            &#125;
            used.insert(nums[i]);
        &#125;
    &#125;
&#125;;
</code></pre>
<p>我在第二个else分支没有取值,并且进入下次回溯</p>
<p>修改后:</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
public:
    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;int&gt; path;
        backtracking(nums,0,path);
        return result;
    &#125;

    void backtracking(vector&lt;int&gt;&amp; nums,int start,vector&lt;int&gt;&amp; path)&#123;
        unordered_set&lt;int&gt; used;
        for(int i=start;i&lt;nums.size();i++)&#123;
            if(!used.empty()&amp;&amp;used.find(nums[i])!=used.end())&#123;
                continue;
            &#125;
            if(path.empty())&#123;
                path.push_back(nums[i]);
                backtracking(nums,i+1,path);
                path.pop_back();
            &#125;else if(nums[i]&gt;=path.back())&#123;
                path.push_back(nums[i]);
                result.push_back(path);
                backtracking(nums,i+1,path);
                path.pop_back();
            &#125;else&#123;
                continue;
            &#125;
            used.insert(nums[i]);
        &#125;
    &#125;
&#125;;
</code></pre>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</code></pre>
<p>示例 2：</p>
<pre><code class="bash">输入：nums = [0,1]
输出：[[0,1],[1,0]]
</code></pre>
<p>思路:使用used数组</p>
<pre><code class="C++">class Solution &#123;
    vector&lt;vector&lt;int&gt;&gt; result;
public:
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;bool&gt; used(nums.size(),false);
        vector&lt;int&gt; path;
        path.clear();
        result.clear();
        backtracking(nums,used,path);
        return result;
    &#125;

    void backtracking(vector&lt;int&gt;&amp; nums,vector&lt;bool&gt;&amp; used,vector&lt;int&gt;&amp; path)&#123;
        if(path.size()==nums.size())&#123;
            result.push_back(path);
            return;
        &#125;
        for(int i=0;i&lt;nums.size();i++)&#123;
            if(used[i])&#123;
                continue;
            &#125;
            path.push_back(nums[i]);
            used[i]=true;
            backtracking(nums,used,path);
            used[i]=false;
            path.pop_back();
        &#125;
    &#125;
&#125;;
</code></pre>
<h2 id="全排列-II"><a href="#全排列-II" class="headerlink" title="全排列 II"></a>全排列 II</h2><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p>
<p>示例 1：</p>
<pre><code>输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
</code></pre>
<p>思路:这个很简单,同一层去重</p>
<pre><code class="C++">class Solution &#123;
    vector&lt;vector&lt;int&gt;&gt; result;
public:
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;bool&gt; used(nums.size(),false);
        vector&lt;int&gt; path;
        path.clear();
        result.clear();
        sort(nums.begin(),nums.end());
        backtracking(nums,used,path);
        return result;
    &#125;

    void backtracking(vector&lt;int&gt;&amp; nums,vector&lt;bool&gt;&amp; used,vector&lt;int&gt;&amp; path)&#123;
        if(path.size()==nums.size())&#123;
            result.push_back(path);
            return;
        &#125;
        int pre=-11;
        for(int i=0;i&lt;nums.size();i++)&#123;
            if(used[i]||nums[i]==pre)&#123;
                continue;
            &#125;
            path.push_back(nums[i]);
            used[i]=true;
            backtracking(nums,used,path);
            used[i]=false;
            path.pop_back();
            pre=nums[i];
        &#125;
    &#125;
&#125;;
</code></pre>
<h1 id="重新写了一遍"><a href="#重新写了一遍" class="headerlink" title="重新写了一遍"></a>重新写了一遍</h1><h2 id="递增子序列-1"><a href="#递增子序列-1" class="headerlink" title="递增子序列"></a>递增子序列</h2><p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。</p>
<p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
</code></pre>
<p>示例 2：</p>
<pre><code class="bash">输入：nums = [4,4,3,2,1]
输出：[[4,4]]
</code></pre>
<p>思路:这题每个回溯的支路层数都不同,需要同一层使用set去重.</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
public:
    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;int&gt; path;
        backtracking(nums,0,path);
        return result;
    &#125;

    void backtracking(vector&lt;int&gt;&amp; nums,int start,vector&lt;int&gt;&amp; path)&#123;
        unordered_set&lt;int&gt; used;
        for(int i=start;i&lt;nums.size();i++)&#123;
            if(!used.empty()&amp;&amp;used.find(nums[i])!=used.end())&#123;
                continue;
            &#125;
            if(path.empty())&#123;
                path.push_back(nums[i]);
                backtracking(nums,i+1,path);
                path.pop_back();
            &#125;else if(nums[i]&gt;=path.back())&#123;
                path.push_back(nums[i]);
                result.push_back(path);
                backtracking(nums,i+1,path);
                path.pop_back();
            &#125;else&#123;
                continue;
            &#125;
            used.insert(nums[i]);
        &#125;
    &#125;
&#125;;
</code></pre>
<h2 id="全排列-1"><a href="#全排列-1" class="headerlink" title="全排列"></a>全排列</h2><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</code></pre>
<p>示例 2：</p>
<pre><code class="bash">输入：nums = [0,1]
输出：[[0,1],[1,0]]
</code></pre>
<p>思路:使用used数组</p>
<pre><code class="C++">class Solution &#123;
    vector&lt;vector&lt;int&gt;&gt; result;
public:
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;bool&gt; used(nums.size(),false);
        vector&lt;int&gt; path;
        path.clear();
        result.clear();
        backtracking(nums,used,path);
        return result;
    &#125;

    void backtracking(vector&lt;int&gt;&amp; nums,vector&lt;bool&gt;&amp; used,vector&lt;int&gt;&amp; path)&#123;
        if(path.size()==nums.size())&#123;
            result.push_back(path);
            return;
        &#125;
        for(int i=0;i&lt;nums.size();i++)&#123;
            if(used[i])&#123;
                continue;
            &#125;
            path.push_back(nums[i]);
            used[i]=true;
            backtracking(nums,used,path);
            used[i]=false;
            path.pop_back();
        &#125;
    &#125;
&#125;;
</code></pre>
<h2 id="全排列-II-1"><a href="#全排列-II-1" class="headerlink" title="全排列 II"></a>全排列 II</h2><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
</code></pre>
<p>示例 2：</p>
<pre><code class="bash">输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</code></pre>
<p>思路:同一层去重 使用used数组</p>
<pre><code class="C++">class Solution &#123;
    vector&lt;vector&lt;int&gt;&gt; result;
public:
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;bool&gt; used(nums.size(),false);
        vector&lt;int&gt; path;
        path.clear();
        result.clear();
        sort(nums.begin(),nums.end());
        backtracking(nums,used,path);
        return result;
    &#125;

    void backtracking(vector&lt;int&gt;&amp; nums,vector&lt;bool&gt;&amp; used,vector&lt;int&gt;&amp; path)&#123;
        if(path.size()==nums.size())&#123;
            result.push_back(path);
            return;
        &#125;
        int pre=-11;
        for(int i=0;i&lt;nums.size();i++)&#123;
            if(used[i]||nums[i]==pre)&#123;
                continue;
            &#125;
            path.push_back(nums[i]);
            used[i]=true;
            backtracking(nums,used,path);
            used[i]=false;
            path.pop_back();
            pre=nums[i];
        &#125;
    &#125;
&#125;;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-12T10:57:31.000Z" itemprop="datePublished">2023-04-12</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-25"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/09/%E7%AE%97%E6%B3%95-day-25/">算法 | day 25</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="组合总和-III"><a href="#组合总和-III" class="headerlink" title="组合总和 III"></a>组合总和 III</h2><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p>
<p>只使用数字1到9<br>每个数字 最多使用一次<br>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;
        vector&lt;int&gt; nums;
        backtracking(nums,k,n,1);
        return result;
    &#125;

    void backtracking(vector&lt;int&gt;&amp; nums,int k,int n,int start)&#123;
        if(9-start+1&lt;k||n&lt;(2*start+k-1)*k/2)&#123;
            return;
        &#125;
        if(n==0&amp;&amp;k==0)&#123;
            result.push_back(nums);
            return;
        &#125;
        for(int i=start;i&lt;10;i++)&#123;
            nums.push_back(i);
            backtracking(nums,k-1,n-i,i+1);
            nums.pop_back();
        &#125;
    &#125;
&#125;;
</code></pre>
<p>这个剪枝是指在剩下的数里面不可能取到和为n的数.</p>
<p>下面的剪枝较为简单:</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result; // 存放结果集
    vector&lt;int&gt; path; // 符合条件的结果
    void backtracking(int targetSum, int k, int sum, int startIndex) &#123;
        if (sum &gt; targetSum) &#123; // 剪枝操作
            return; // 如果path.size() == k 但sum != targetSum 直接返回
        &#125;
        if (path.size() == k) &#123;
            if (sum == targetSum) result.push_back(path);
            return;
        &#125;
        for (int i = startIndex; i &lt;= 9 - (k - path.size()) + 1; i++) &#123; // 剪枝
            sum += i; // 处理
            path.push_back(i); // 处理
            backtracking(targetSum, k, sum, i + 1); // 注意i+1调整startIndex
            sum -= i; // 回溯
            path.pop_back(); // 回溯
        &#125;
    &#125;

public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;
        result.clear(); // 可以不加
        path.clear();   // 可以不加
        backtracking(n, k, 0, 1);
        return result;
    &#125;
&#125;;
</code></pre>
<h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="/images/leetcode/200px-telephone-keypad2svg.png" alt="手机·"></p>
<p>思路:回溯</p>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
private:
    const string letterMap[10] = &#123;
        &quot;&quot;, // 0
        &quot;&quot;, // 1
        &quot;abc&quot;, // 2
        &quot;def&quot;, // 3
        &quot;ghi&quot;, // 4
        &quot;jkl&quot;, // 5
        &quot;mno&quot;, // 6
        &quot;pqrs&quot;, // 7
        &quot;tuv&quot;, // 8
        &quot;wxyz&quot;, // 9
    &#125;;

    vector&lt;string&gt; result;
public:
    vector&lt;string&gt; letterCombinations(string digits) &#123;
        if(digits.empty())&#123;
            return &#123;&#125;;
        &#125;
        string path;
        backtracking(path,digits,0);
        return result;
    &#125;

    void backtracking(string&amp; path,string digits,int n)&#123;
        if(n==digits.size())&#123;
            result.push_back(path);
            return;
        &#125;
        int num=digits[n]-&#39;0&#39;;
        for(int i=0;i&lt;letterMap[num].size();i++)&#123;
            path.push_back(letterMap[num][i]);
            backtracking(path,digits,n+1);
            path.pop_back();
        &#125;
    &#125;
&#125;;
</code></pre>
<p>优化:使用<code>const string</code></p>
<pre><code class="C++">// 版本二
class Solution &#123;
private:
        const string letterMap[10] = &#123;
            &quot;&quot;, // 0
            &quot;&quot;, // 1
            &quot;abc&quot;, // 2
            &quot;def&quot;, // 3
            &quot;ghi&quot;, // 4
            &quot;jkl&quot;, // 5
            &quot;mno&quot;, // 6
            &quot;pqrs&quot;, // 7
            &quot;tuv&quot;, // 8
            &quot;wxyz&quot;, // 9
        &#125;;
public:
    vector&lt;string&gt; result;
    void getCombinations(const string&amp; digits, int index, const string&amp; s) &#123; // 注意参数的不同
        if (index == digits.size()) &#123;
            result.push_back(s);
            return;
        &#125;
        int digit = digits[index] - &#39;0&#39;;
        string letters = letterMap[digit];
        for (int i = 0; i &lt; letters.size(); i++) &#123;
            getCombinations(digits, index + 1, s + letters[i]);  // 注意这里的不同
        &#125;
    &#125;
    vector&lt;string&gt; letterCombinations(string digits) &#123;
        result.clear();
        if (digits.size() == 0) &#123;
            return result;
        &#125;
        getCombinations(digits, 0, &quot;&quot;);
        return result;

    &#125;
&#125;;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-09T08:36:33.000Z" itemprop="datePublished">2023-04-09</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-24"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/09/%E7%AE%97%E6%B3%95-day-24/">算法 | day 24</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h2><p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<h2 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="回溯法模板"></a>回溯法模板</h2><p>模板:</p>
<pre><code class="C++">void backtracking(参数) &#123;
    if (终止条件) &#123;
        存放结果;
        return;
    &#125;

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    &#125;
&#125;
</code></pre>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p>
<p>你可以按 任何顺序 返回答案。</p>
<p>思路:回溯</p>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
public:
    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;
        backTracking(&#123;&#125;,n,k,1);
        return result;
    &#125;

    void backTracking(vector&lt;int&gt; nums,int n,int k,int start)&#123;
        if(start&gt;n-k+1)&#123;
            return;
        &#125;
        if(k==0)&#123;
            result.push_back(nums);
            return;
        &#125;
        for(int i=start;i&lt;=n;i++)&#123;
            nums.push_back(i);
            backTracking(nums,n,k-1,i+1);
            nums.pop_back();
        &#125;
    &#125;
&#125;;
</code></pre>
<p> 改进:要么把<code>vector&lt;int&gt; nums</code>写外面,要么写引用,回溯算法的参数应该传引用.</p>
<p>例子:</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result; // 存放符合条件结果的集合
    vector&lt;int&gt; path; // 用来存放符合条件结果
    void backtracking(int n, int k, int startIndex) &#123;
        if (path.size() == k) &#123;
            result.push_back(path);
            return;
        &#125;
        for (int i = startIndex; i &lt;= n; i++) &#123;
            path.push_back(i); // 处理节点
            backtracking(n, k, i + 1); // 递归
            path.pop_back(); // 回溯，撤销处理的节点
        &#125;
    &#125;
public:
    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;
        result.clear(); // 可以不写
        path.clear();   // 可以不写
        backtracking(n, k, 1);
        return result;
    &#125;
&#125;;
</code></pre>
<p>剪枝优化后:</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void backtracking(int n, int k, int startIndex) &#123;
        if (path.size() == k) &#123;
            result.push_back(path);
            return;
        &#125;
        for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) &#123; // 优化的地方
            path.push_back(i); // 处理节点
            backtracking(n, k, i + 1);
            path.pop_back(); // 回溯，撤销处理的节点
        &#125;
    &#125;
public:

    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;
        backtracking(n, k, 1);
        return result;
    &#125;
&#125;;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-09T04:17:26.000Z" itemprop="datePublished">2023-04-09</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-13"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/02/%E7%AE%97%E6%B3%95-day-13/">算法 | day 13</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 滑动窗口中的最大值 </p>
<p>示例 1：</p>
<pre><code class="bash">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</code></pre>
<p>示例 2：</p>
<pre><code class="bash">输入：nums = [1], k = 1
输出：[1]
</code></pre>
<p>思路:</p>
<p>使用双端队列:</p>
<ul>
<li>当队尾大于等于num时,push_back(num);</li>
<li>当队尾小于num时,一直执行pop_back()操作,直到队尾大于等于num,push_back(num)</li>
<li>这题只需要关心滑动窗口最大值的位置,所以当队尾等于num时,需要push_back(num)</li>
<li>当活动窗口右移,需要判断上一个窗口的最大值是否被被划出,若是,则要重新寻找最大值</li>
</ul>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;
        deque&lt;int&gt; que;
        vector&lt;int&gt; maxnum;
        for(int i=0;i&lt;k;i++)&#123;
            if(!que.empty()&amp;&amp;nums[i]&lt;=que.back())&#123;
                que.push_back(nums[i]);
            &#125;else&#123;
                while(!que.empty()&amp;&amp;que.back()&lt;nums[i])&#123;
                    que.pop_back();
                &#125;
                que.push_back(nums[i]);
            &#125;
        &#125;

        int max=que.front();
        maxnum.push_back(max);

        for(int i=k;i&lt;nums.size();i++)&#123;
            if(nums[i-k]==que.front())&#123;
                que.pop_front();
            &#125;
            if(!que.empty()&amp;&amp;nums[i]&lt;=que.back())&#123;
                que.push_back(nums[i]);
            &#125;else&#123;
                while(!que.empty()&amp;&amp;que.back()&lt;nums[i])&#123;
                    que.pop_back();
                &#125;
                que.push_back(nums[i]);
            &#125;
            int max=que.front();
            maxnum.push_back(max);
        &#125;

        return maxnum;
    &#125;
&#125;;
</code></pre>
<p>例子:</p>
<pre><code class="C++">class Solution &#123;
private:
    class MyQueue &#123; //单调队列（从大到小）
    public:
        deque&lt;int&gt; que; // 使用deque来实现单调队列
        // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。
        // 同时pop之前判断队列当前是否为空。
        void pop(int value) &#123;
            if (!que.empty() &amp;&amp; value == que.front()) &#123;
                que.pop_front();
            &#125;
        &#125;
        // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
        // 这样就保持了队列里的数值是单调从大到小的了。
        void push(int value) &#123;
            while (!que.empty() &amp;&amp; value &gt; que.back()) &#123;
                que.pop_back();
            &#125;
            que.push_back(value);

        &#125;
        // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
        int front() &#123;
            return que.front();
        &#125;
    &#125;;
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;
        MyQueue que;
        vector&lt;int&gt; result;
        for (int i = 0; i &lt; k; i++) &#123; // 先将前k的元素放进队列
            que.push(nums[i]);
        &#125;
        result.push_back(que.front()); // result 记录前k的元素的最大值
        for (int i = k; i &lt; nums.size(); i++) &#123;
            que.pop(nums[i - k]); // 滑动窗口移除最前面元素
            que.push(nums[i]); // 滑动窗口前加入最后面的元素
            result.push_back(que.front()); // 记录对应的最大值
        &#125;
        return result;
    &#125;
&#125;;
</code></pre>
<p>例子思路差不多,只是自己实现了一个队列</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-02T09:59:40.000Z" itemprop="datePublished">2023-04-02</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-C-string-int-转换"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/02/C-string-int-%E8%BD%AC%E6%8D%A2/">C++ string int 转换</a>
    </header>
    <div class="article-entry post-inner-html">
        
        
        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-02T07:13:58.000Z" itemprop="datePublished">2023-04-02</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-11"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/02/%E7%AE%97%E6%B3%95-day-11/">算法 | day 11</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p>
<p>思路:利用栈的特性</p>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    bool isValid(string s) &#123;
        stack&lt;char&gt; st;
        for(int i=0;i&lt;s.size();i++)&#123;
            if(s[i]==&#39;)&#39;)&#123;
                if(st.empty())&#123;
                    return false;
                &#125;
                int tmp=st.top();
                st.pop();
                if(tmp!=&#39;(&#39;)&#123;
                    return false;
                &#125;
            &#125;else if(s[i]==&#39;]&#39;)&#123;
                if(st.empty())&#123;
                    return false;
                &#125;
                int tmp=st.top();
                st.pop();
                if(tmp!=&#39;[&#39;)&#123;
                    return false;
                &#125;
            &#125;else if(s[i]==&#39;&#125;&#39;)&#123;
                if(st.empty())&#123;
                    return false;
                &#125;
                int tmp=st.top();
                st.pop();
                if(tmp!=&#39;&#123;&#39;)&#123;
                    return false;
                &#125;
            &#125;else&#123;
                st.push(s[i]);
            &#125;
        &#125;

        return st.empty();
    &#125;
&#125;;
</code></pre>
<p>例子: 简单一点</p>
<pre><code class="C++">class Solution &#123;
public:
    bool isValid(string s) &#123;
        if (s.size() % 2 != 0) return false; // 如果s的长度为奇数，一定不符合要求
        stack&lt;char&gt; st;
        for (int i = 0; i &lt; s.size(); i++) &#123;
            if (s[i] == &#39;(&#39;) st.push(&#39;)&#39;);
            else if (s[i] == &#39;&#123;&#39;) st.push(&#39;&#125;&#39;);
            else if (s[i] == &#39;[&#39;) st.push(&#39;]&#39;);
            // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false
            // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false
            else if (st.empty() || st.top() != s[i]) return false;
            else st.pop(); // st.top() 与 s[i]相等，栈弹出元素
        &#125;
        // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true
        return st.empty();
    &#125;
&#125;;
</code></pre>
<h2 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h2><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>示例：</p>
<pre><code class="bash">输入：&quot;abbaca&quot;
输出：&quot;ca&quot;
解释：
例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。
</code></pre>
<p>思路:使用栈<br>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    string removeDuplicates(string s) &#123;
        stack&lt;char&gt; st;
        for(int i=0;i&lt;s.size();i++)&#123;
            if(st.empty())&#123;
                st.push(s[i]);
            &#125;else&#123;
                char tmp=st.top();
                if(tmp==s[i])&#123;
                    st.pop();
                &#125;else&#123;
                    st.push(s[i]);
                &#125;
            &#125;
        &#125;

        string res;
        while(!st.empty())&#123;
            char tmp=st.top();
            st.pop();
            res.push_back(tmp);
        &#125;
        reverse(res.begin(),res.end());
        return res;
    &#125;
&#125;;
</code></pre>
<p>例子: </p>
<pre><code class="C++">class Solution &#123;
public:
    string removeDuplicates(string S) &#123;
        string result;
        for(char s : S) &#123;
            if(result.empty() || result.back() != s) &#123;
                result.push_back(s);
            &#125;
            else &#123;
                result.pop_back();
            &#125;
        &#125;
        return result;
    &#125;
&#125;;
</code></pre>
<p>这里直接用string当容器,节省操作</p>
<h2 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h2><p>给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<p>注意：</p>
<ul>
<li>有效的算符为 ‘+’、’-‘、’*’ 和 ‘&#x2F;‘ 。</li>
<li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li>
<li>两个整数之间的除法总是 向零截断 。</li>
<li>表达式中不含除零运算。</li>
<li>输入是一个根据逆波兰表示法表示的算术表达式。</li>
<li>答案及所有中间计算结果可以用 32 位 整数表示。</li>
</ul>
<p>思路:使用栈</p>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;
        stack&lt;string&gt; st;
        for(int i=0;i&lt;tokens.size();i++)&#123;
            if(tokens[i]==&quot;+&quot;)&#123;
                int num1=atoi(st.top().c_str());
                st.pop();
                int num2=atoi(st.top().c_str());
                st.pop();
                st.push(to_string(num1+num2));
            &#125;else if(tokens[i]==&quot;-&quot;)&#123;
                int num1=atoi(st.top().c_str());
                st.pop();
                int num2=atoi(st.top().c_str());
                st.pop();
                st.push(to_string(num2-num1));
            &#125;else if(tokens[i]==&quot;*&quot;)&#123;
                int num1=atoi(st.top().c_str());
                st.pop();
                int num2=atoi(st.top().c_str());
                st.pop();
                st.push(to_string(num1*num2));
            &#125;else if(tokens[i]==&quot;/&quot;)&#123;
                int num1=atoi(st.top().c_str());
                st.pop();
                int num2=atoi(st.top().c_str());
                st.pop();
                st.push(to_string(num2/num1));
            &#125;else&#123;
                st.push(tokens[i]);
            &#125;
        &#125; 

        return  atoi(st.top().c_str());
    &#125;
&#125;;
</code></pre>
<p>例子:</p>
<pre><code class="C++">class Solution &#123;
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;
        // 力扣修改了后台测试数据，需要用longlong
        stack&lt;long long&gt; st; 
        for (int i = 0; i &lt; tokens.size(); i++) &#123;
            if (tokens[i] == &quot;+&quot; || tokens[i] == &quot;-&quot; || tokens[i] == &quot;*&quot; || tokens[i] == &quot;/&quot;) &#123;
                long long num1 = st.top();
                st.pop();
                long long num2 = st.top();
                st.pop();
                if (tokens[i] == &quot;+&quot;) st.push(num2 + num1);
                if (tokens[i] == &quot;-&quot;) st.push(num2 - num1);
                if (tokens[i] == &quot;*&quot;) st.push(num2 * num1);
                if (tokens[i] == &quot;/&quot;) st.push(num2 / num1);
            &#125; else &#123;
                st.push(stoll(tokens[i]));
            &#125;
        &#125;

        int result = st.top();
        st.pop(); // 把栈里最后一个元素弹出（其实不弹出也没事）
        return result;
    &#125;
&#125;;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-02T06:49:48.000Z" itemprop="datePublished">2023-04-02</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-10"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/02/%E7%AE%97%E6%B3%95-day-10/">算法 | day 10</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。</p>
<p>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</p>
<p>所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。</p>
<p>栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。</p>
<p>我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。</p>
<p>deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。</p>
<p>SGI STL中 队列底层实现缺省情况下一样使用deque实现的。</p>
<p>我们也可以指定vector为栈的底层实现，初始化语句如下：</p>
<pre><code>std::stack&lt;int, std::vector&lt;int&gt; &gt; third;  // 使用vector为底层容器的栈
</code></pre>
<p>对应的队列的情况是一样的。</p>
<p>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, SGI STL中队列一样是以deque为缺省情况下的底部结构。</p>
<p>也可以指定list 为起底层实现，初始化queue的语句如下：</p>
<pre><code>std::queue&lt;int, std::list&lt;int&gt;&gt; third; // 定义以list为底层容器的队列
</code></pre>
<p>所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。</p>
<h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p>实现 MyQueue 类：</p>
<p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：</p>
<ul>
<li>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
</ul>
<p>思路:用一个栈处理push,另一个栈处理pop</p>
<p>提交:</p>
<pre><code class="C++">class MyQueue &#123;
private:
    stack&lt;int&gt; stack1;
    stack&lt;int&gt; stack2;
public:
    MyQueue() &#123;
        
    &#125;
    
    void push(int x) &#123;
        stack1.push(x);
    &#125;
    
    int pop() &#123;
        if(stack2.empty())&#123;
            while(!stack1.empty())&#123;
                int num=stack1.top();
                stack1.pop();
                stack2.push(num);
            &#125;
        &#125;
        int res=stack2.top();
        stack2.pop();
        return res;
    &#125;
    
    int peek() &#123;
        if(stack2.empty())&#123;
            while(!stack1.empty())&#123;
                int num=stack1.top();
                stack1.pop();
                stack2.push(num);
            &#125;
        &#125;
        int res=stack2.top();
        return res;
    &#125;
    
    bool empty() &#123;
        return stack1.empty()&amp;&amp;stack2.empty();
    &#125;
&#125;;
</code></pre>
<h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>
<p>实现 MyStack 类：</p>
<ul>
<li>void push(int x) 将元素 x 压入栈顶。</li>
<li>int pop() 移除并返回栈顶元素。</li>
<li>int top() 返回栈顶元素。</li>
<li>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</li>
</ul>
<p>思路:只用一个队列</p>
<p>提交:</p>
<pre><code class="C++">class MyStack &#123;
    queue&lt;int&gt; q;
public:
    MyStack() &#123;

    &#125;
    
    void push(int x) &#123;
        q.push(x);
    &#125;
    
    int pop() &#123;
        for(int i=0;i&lt;q.size()-1;i++)&#123;
            int num=q.front();
            q.pop();
            q.push(num);
        &#125;
        int res=q.front();
        q.pop();
        return res;
    &#125;
    
    int top() &#123;
        return q.back();
    &#125;
    
    bool empty() &#123;
        return q.empty();
    &#125;
&#125;;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-02T04:19:55.000Z" itemprop="datePublished">2023-04-02</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-18"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/01/%E7%AE%97%E6%B3%95-day-18/">算法 | day 18</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h2><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>
<p>思路:层序遍历</p>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    int findBottomLeftValue(TreeNode* root) &#123;
        return traversal(root);
    &#125;

    int traversal(TreeNode* root)&#123;
        TreeNode* res;
        queue&lt;TreeNode*&gt; nodes;
        nodes.push(root);
        while(!nodes.empty())&#123;
            int size=nodes.size();
            TreeNode* node=nodes.front();
            res=node;
            nodes.pop();
            if(node-&gt;left)&#123;
                nodes.push(node-&gt;left);
            &#125;
            if(node-&gt;right)&#123;
                nodes.push(node-&gt;right);
            &#125;

            for(int i=0;i&lt;size-1;i++)&#123;
                TreeNode* node=nodes.front();
                nodes.pop();
                if(node-&gt;left)&#123;
                    nodes.push(node-&gt;left);
                &#125;
                if(node-&gt;right)&#123;
                    nodes.push(node-&gt;right);
                &#125;
            &#125;
        &#125;

        return res-&gt;val;
    &#125;   
&#125;;
</code></pre>
<p>回溯法例子:</p>
<pre><code class="C++">class Solution &#123;
public:
    int maxDepth = INT_MIN;
    int result;
    void traversal(TreeNode* root, int depth) &#123;
        if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123;
            if (depth &gt; maxDepth) &#123;
                maxDepth = depth;
                result = root-&gt;val;
            &#125;
            return;
        &#125;
        if (root-&gt;left) &#123;
            traversal(root-&gt;left, depth + 1); // 隐藏着回溯
        &#125;
        if (root-&gt;right) &#123;
            traversal(root-&gt;right, depth + 1); // 隐藏着回溯
        &#125;
        return;
    &#125;
    int findBottomLeftValue(TreeNode* root) &#123;
        traversal(root, 0);
        return result;
    &#125;
&#125;;
</code></pre>
<p>其实可以把回溯法的代码看成是前序遍历,在遍历的过程中最下最左的节点一定是比同一层的右节点先遍历到.所以判断条件是 <code>depth &gt; maxDepth</code></p>
<p>迭代法例子: (层序遍历)</p>
<pre><code class="C++">class Solution &#123;
public:
    int findBottomLeftValue(TreeNode* root) &#123;
        queue&lt;TreeNode*&gt; que;
        if (root != NULL) que.push(root);
        int result = 0;
        while (!que.empty()) &#123;
            int size = que.size();
            for (int i = 0; i &lt; size; i++) &#123;
                TreeNode* node = que.front();
                que.pop();
                if (i == 0) result = node-&gt;val; // 记录最后一行第一个元素
                if (node-&gt;left) que.push(node-&gt;left);
                if (node-&gt;right) que.push(node-&gt;right);
            &#125;
        &#125;
        return result;
    &#125;
&#125;;
</code></pre>
<h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h2><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p>
<p>叶子节点 是指没有子节点的节点</p>
<p>思路:递归</p>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    bool hasPathSum(TreeNode* root, int targetSum) &#123;
        if(!root)&#123;
            return false;
        &#125;
        if(!root-&gt;right&amp;&amp;!root-&gt;left)&#123;
            return root-&gt;val==targetSum;
        &#125;else&#123;
            return hasPathSum(root-&gt;left,targetSum-root-&gt;val)||hasPathSum(root-&gt;right,targetSum-root-&gt;val);
        &#125;
    &#125;
&#125;;
</code></pre>
<h2 id="路径总和-II"><a href="#路径总和-II" class="headerlink" title="路径总和 II"></a>路径总和 II</h2><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p>思路:递归</p>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
    vector&lt;vector&lt;int&gt;&gt; res;
public:
    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;
        traversal(root,targetSum,&#123;&#125;);
        return res;
    &#125;

    void traversal(TreeNode* root, int targetSum,vector&lt;int&gt; nums)&#123;
        if(!root)&#123;
            return;
        &#125;
        nums.push_back(root-&gt;val);
        if(!root-&gt;left&amp;&amp;!root-&gt;right)&#123;
            if(root-&gt;val==targetSum)&#123;
                res.push_back(nums);
            &#125;
            return;
        &#125;
        traversal(root-&gt;left,targetSum-root-&gt;val,nums);
        traversal(root-&gt;right,targetSum-root-&gt;val,nums);
    &#125;
&#125;;
</code></pre>
<p>回溯法例子:</p>
<pre><code class="C++">class solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    // 递归函数不需要返回值，因为我们要遍历整个树
    void traversal(treenode* cur, int count) &#123;
        if (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == 0) &#123; // 遇到了叶子节点且找到了和为sum的路径
            result.push_back(path);
            return;
        &#125;

        if (!cur-&gt;left &amp;&amp; !cur-&gt;right) return ; // 遇到叶子节点而没有找到合适的边，直接返回

        if (cur-&gt;left) &#123; // 左 （空节点不遍历）
            path.push_back(cur-&gt;left-&gt;val);
            count -= cur-&gt;left-&gt;val;
            traversal(cur-&gt;left, count);    // 递归
            count += cur-&gt;left-&gt;val;        // 回溯
            path.pop_back();                // 回溯
        &#125;
        if (cur-&gt;right) &#123; // 右 （空节点不遍历）
            path.push_back(cur-&gt;right-&gt;val);
            count -= cur-&gt;right-&gt;val;
            traversal(cur-&gt;right, count);   // 递归
            count += cur-&gt;right-&gt;val;       // 回溯
            path.pop_back();                // 回溯
        &#125;
        return ;
    &#125;

public:
    vector&lt;vector&lt;int&gt;&gt; pathsum(treenode* root, int sum) &#123;
        result.clear();
        path.clear();
        if (root == null) return result;
        path.push_back(root-&gt;val); // 把根节点放进路径
        traversal(root, sum - root-&gt;val);
        return result;
    &#125;
&#125;;
</code></pre>
<h2 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h2><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p>
<p>思路:先后续遍历的数组选最后一个,即中间节点,再从中序遍历数组找到这个节点</p>
<p>提交:</p>
<pre><code class="C++">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;
        int size=inorder.size();
        return build(inorder,postorder,0,size-1,0,size-1);
    &#125;

    TreeNode* build(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder,int istart,int iend,int pstart,int pend)&#123;
        if(iend&lt;istart||pend&lt;pstart)&#123;
            return nullptr;
        &#125;
        int val=postorder[pend];
        TreeNode* node=new TreeNode(val);
        int imid=0;
        for(int i=istart;i&lt;=iend;i++)&#123;
            if(inorder[i]==val)&#123;
                imid=i;
                break;
            &#125;
        &#125;
        node-&gt;left=build(inorder,postorder,istart,imid-1,pstart,pstart+imid-istart-1);
        node-&gt;right=build(inorder,postorder,imid+1,iend,pstart+imid-istart,pend-1);
        return node;
    &#125;
&#125;;
</code></pre>
<p>例子:</p>
<pre><code class="C++">class Solution &#123;
private:
    // 中序区间：[inorderBegin, inorderEnd)，后序区间[postorderBegin, postorderEnd)
    TreeNode* traversal (vector&lt;int&gt;&amp; inorder, int inorderBegin, int inorderEnd, vector&lt;int&gt;&amp; postorder, int postorderBegin, int postorderEnd) &#123;
        if (postorderBegin == postorderEnd) return NULL;

        int rootValue = postorder[postorderEnd - 1];
        TreeNode* root = new TreeNode(rootValue);

        if (postorderEnd - postorderBegin == 1) return root;

        int delimiterIndex;
        for (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) &#123;
            if (inorder[delimiterIndex] == rootValue) break;
        &#125;
        // 切割中序数组
        // 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)
        int leftInorderBegin = inorderBegin;
        int leftInorderEnd = delimiterIndex;
        // 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)
        int rightInorderBegin = delimiterIndex + 1;
        int rightInorderEnd = inorderEnd;

        // 切割后序数组
        // 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)
        int leftPostorderBegin =  postorderBegin;
        int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; // 终止位置是 需要加上 中序区间的大小size
        // 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)
        int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);
        int rightPostorderEnd = postorderEnd - 1; // 排除最后一个元素，已经作为节点了

        root-&gt;left = traversal(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);
        root-&gt;right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);

        return root;
    &#125;
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;
        if (inorder.size() == 0 || postorder.size() == 0) return NULL;
        // 左闭右开的原则
        return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size());
    &#125;
&#125;;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-01T05:38:35.000Z" itemprop="datePublished">2023-04-01</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-17"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/03/31/%E7%AE%97%E6%B3%95-day-17/">算法 | day 17</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<p>思路:递归</p>
<pre><code class="C++">class Solution &#123;
    bool res=true;
public:
    bool isBalanced(TreeNode* root) &#123;
        traversal(root);
        return res;
    &#125;

    int traversal(TreeNode* root)&#123;
        if(!root)&#123;
            return 0;
        &#125;
        int rdepth = traversal(root-&gt;right);
        int ldepth = traversal(root-&gt;left);
        if(rdepth&gt;=ldepth)&#123;
            if(rdepth-ldepth&gt;1)&#123;
                res = false;
            &#125;
            return rdepth+1;
        &#125;else&#123;
            if(ldepth-rdepth&gt;1)&#123;
                res = false;
            &#125;
            return ldepth+1;
        &#125;
        
    &#125;
&#125;;
</code></pre>
<p>其实可以在判断为不是二叉树时返回-1</p>
<p>例子:</p>
<pre><code class="C++">class Solution &#123;
public:
    // 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1
    int getHeight(TreeNode* node) &#123;
        if (node == NULL) &#123;
            return 0;
        &#125;
        int leftHeight = getHeight(node-&gt;left);
        if (leftHeight == -1) return -1;
        int rightHeight = getHeight(node-&gt;right);
        if (rightHeight == -1) return -1;
        return abs(leftHeight - rightHeight) &gt; 1 ? -1 : 1 + max(leftHeight, rightHeight);
    &#125;
    bool isBalanced(TreeNode* root) &#123;
        return getHeight(root) == -1 ? false : true;
    &#125;
&#125;;
</code></pre>
<h2 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h2><p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p>思路:回溯</p>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
    //string path;
    vector&lt;string&gt; path;
public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;
        if(root==nullptr)&#123;
            return &#123;&#125;;
        &#125;
        if(root-&gt;left==nullptr&amp;&amp;root-&gt;right==nullptr)&#123;
            path.push_back(to_string(root-&gt;val));
            return path;
        &#125;

        traversal(root-&gt;left,to_string(root-&gt;val));
        traversal(root-&gt;right,to_string(root-&gt;val));
        return path;
    &#125;

    void traversal(TreeNode* root,string str)&#123;
        if(!root)&#123;
            return ;
        &#125;
        if(root-&gt;left==nullptr&amp;&amp;root-&gt;right==nullptr)&#123;
            path.push_back(str+&quot;-&gt;&quot;+to_string(root-&gt;val));
            return;
        &#125;
        traversal(root-&gt;left,str+&quot;-&gt;&quot;+to_string(root-&gt;val));
        traversal(root-&gt;right,str+&quot;-&gt;&quot;+to_string(root-&gt;val));
    &#125;
&#125;;
</code></pre>
<p>例子:</p>
<pre><code class="C++">class Solution &#123;
private:

    void traversal(TreeNode* cur, string path, vector&lt;string&gt;&amp; result) &#123;
        path += to_string(cur-&gt;val); // 中
        if (cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL) &#123;
            result.push_back(path);
            return;
        &#125;
        if (cur-&gt;left) traversal(cur-&gt;left, path + &quot;-&gt;&quot;, result); // 左
        if (cur-&gt;right) traversal(cur-&gt;right, path + &quot;-&gt;&quot;, result); // 右
    &#125;

public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;
        vector&lt;string&gt; result;
        string path;
        if (root == NULL) return result;
        traversal(root, path, result);
        return result;

    &#125;
&#125;;
</code></pre>
<h2 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h2><p>给定二叉树的根节点 root ，返回所有左叶子之和。</p>
<p>思路:递归</p>
<p>提交</p>
<pre><code class="C++">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    int sumOfLeftLeaves(TreeNode* root) &#123;
        if(!root)&#123;
            return 0;
        &#125;
       if(root-&gt;left&amp;&amp;!root-&gt;left-&gt;left&amp;&amp;!root-&gt;left-&gt;right)&#123;
           return root-&gt;left-&gt;val+sumOfLeftLeaves(root-&gt;right);
       &#125;

       return sumOfLeftLeaves(root-&gt;left)+sumOfLeftLeaves(root-&gt;right);
    &#125;
&#125;;
</code></pre>
<p>迭代法例子:</p>
<pre><code class="C++">class Solution &#123;
public:
    int sumOfLeftLeaves(TreeNode* root) &#123;
        stack&lt;TreeNode*&gt; st;
        if (root == NULL) return 0;
        st.push(root);
        int result = 0;
        while (!st.empty()) &#123;
            TreeNode* node = st.top();
            st.pop();
            if (node-&gt;left != NULL &amp;&amp; node-&gt;left-&gt;left == NULL &amp;&amp; node-&gt;left-&gt;right == NULL) &#123;
                result += node-&gt;left-&gt;val;
            &#125;
            if (node-&gt;right) st.push(node-&gt;right);
            if (node-&gt;left) st.push(node-&gt;left);
        &#125;
        return result;
    &#125;
&#125;;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-03-31T11:06:07.000Z" itemprop="datePublished">2023-03-31</time>
</div>
    
    
    </div>
</footer>

</article>

    
  

  
    <nav class="pagination">
        <a class="extend prev" rel="prev" href="/page/2/">Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next</a>
    </nav>
  
</div>

                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
    
      

    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-34/">算法 | day 34</a>
          </li>
        
          <li>
            <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-32/">算法 | day 32</a>
          </li>
        
          <li>
            <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-31/">算法 | day 31</a>
          </li>
        
          <li>
            <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-30/">算法 | day 30</a>
          </li>
        
          <li>
            <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-28/">算法 | day 28</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            Hexo &copy; 2023<br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>

<script type="module" src="https://unpkg.com/ionicons@6.0.2/dist/ionicons/ionicons.esm.js"></script>






<script src="/dist/build.js?1654266144177.js"></script>


<script src="/dist/custom.js?1654266144177.js"></script>













</body>

</html>