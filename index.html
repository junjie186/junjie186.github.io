<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>Hexo</title>

    <meta name="description" content="Hexo">
    <meta name="keywords" content="">

    



    <meta property="og:type" content="website"/>
    <meta property="og:title" content=""/>
    <meta property="og:description" content=""/>
    <meta property="og:locale" content="cn" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="http://example.com/index.html" />
    <meta property="og:site_name" content="John Doe" />
    <meta property="article:publisher" content="" />
    <script type="application/ld+json">
        {
            "@context": "https://schema.org",
            "@type": "WebPage",
            "name": "",
            "description": "",
            "publisher": {
                "@type": "Organization",
                "name": "John Doe"
            },
        }
    </script>


    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1654266144177.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1654266144177.css">


    <script>
        window.isPost = false
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/avatar.jpg" alt="John Doe">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>Hexo</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="index">
  
    
      <article
id="post-算法-day-2"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/03/20/%E7%AE%97%E6%B3%95-day-2/">算法 | day 2</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <blockquote>
<p>本文参考自 <a target="_blank" rel="noopener" href="https://programmercarl.com/">代码随想录</a></p>
</blockquote>
<h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p>示例 1： 输入：nums &#x3D; [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p>
<p>示例 2： 输入：nums &#x3D; [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p>
<p>我的思路:找到数组的正负分界,然后用归并排序.</p>
<blockquote>
<p><font color="red">使用双指针法更简单</font></p>
</blockquote>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;
        int index1=0;
        while(index1!=nums.size())&#123;
            if(nums[index1]&gt;0)&#123;
                break;
            &#125;
            index1++;
        &#125;
        int index2=index1-1;
        //没有初始化长度
        vector&lt;int&gt; ret;
        while(index2!=-1&amp;&amp;index1!=nums.size())&#123;
            if(nums[index1]*nums[index1]&lt;=nums[index2]*nums[index2])&#123;
                ret.push_back(nums[index1]*nums[index1]);
                index1++;
            &#125;else&#123;
                ret.push_back(nums[index2]*nums[index2]);
                index2--;
            &#125;
        &#125;
        for(;index1&lt;nums.size();index1++)&#123;
            ret.push_back(nums[index1]*nums[index1]);
        &#125;
        for(;index2&gt;=0;index2--)&#123;
            ret.push_back(nums[index2]*nums[index2]);
        &#125;
        return ret;
    &#125;
&#125;;
</code></pre>
<p>例子,使用双指针法:</p>
<pre><code class="C++">class Solution &#123;
public:
    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123;
        int k = A.size() - 1;
        vector&lt;int&gt; result(A.size(), 0);
        for (int i = 0, j = A.size() - 1; i &lt;= j;) &#123; // 注意这里要i &lt;= j，因为最后要处理两个元素
            if (A[i] * A[i] &lt; A[j] * A[j])  &#123;
                result[k--] = A[j] * A[j];
                j--;
            &#125;
            else &#123;
                result[k--] = A[i] * A[i];
                i++;
            &#125;
        &#125;
        return result;
    &#125;
&#125;;
</code></pre>
<h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p>示例：</p>
<p>输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p>
<p>思路:滑动窗口</p>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;
        int left=0,right =0;
        int length=nums.size()+1;
        int sum=0;
        for(;right&lt;nums.size();right++)&#123;
            sum+=nums[right];
            if(sum&gt;=target)&#123;
                length=(right-left+1)&lt;length?(right-left+1):length;
                for(;left&lt;right;)&#123;
                    sum-=nums[left];
                    left++;
                    if(sum&gt;=target)&#123;
                        length=(right-left+1)&lt;length?(right-left+1):length;
                    &#125;else&#123;
                        break;
                    &#125;
                &#125;
            &#125;
            
        &#125;
        if(length&gt;nums.size())&#123;
            return 0;
        &#125;else&#123;
            return length;
        &#125;
    &#125;
&#125;;
</code></pre>
<p>例子:</p>
<pre><code class="C++">class Solution &#123;
public:
    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j &lt; nums.size(); j++) &#123;
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum &gt;= s) &#123;
                subLength = (j - i + 1); // 取子序列的长度
                result = result &lt; subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            &#125;
        &#125;
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    &#125;
&#125;;
</code></pre>
<p>思路其实一样,但写的更简洁</p>
<h2 id="螺旋矩阵II"><a href="#螺旋矩阵II" class="headerlink" title="螺旋矩阵II"></a>螺旋矩阵II</h2><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<p>示例:</p>
<p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p>
<p>思路:要利用循环层数</p>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n)
&#123;
    int i = 0, j = 0;
    int num = 1;
    vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0));
    int k = 1;
    res[0][0] = k;
    k++;
    i++;
    while (k &lt;= n * n)
    &#123;
        switch (num % 4)
        &#123;
        case 1:
            for (; i &lt; n - num / 4; i++)
            &#123;
                res[j][i] = k;
                k++;
            &#125;
            //这里第一次提交没有写,导致出错
            i--;
            j++;
            num++;
            break;
        case 2:
            for (; j &lt; n - num / 4; j++)
            &#123;
                res[j][i] = k;
                k++;
            &#125;
            j--;
            i--;
            num++;
            break;
        case 3:
            for (; i &gt;= num / 4; i--)
            &#123;
                res[j][i] = k;
                k++;
            &#125;
            i++;
            j--;
            num++;
            break;
        case 0:
            for (; j &gt;= num / 4; j--)
            &#123;
                res[j][i] = k;
                k++;
            &#125;
            j++;
            i++;
            num++;
            break;
        &#125;
    &#125;
    return res;
&#125;

&#125;;
</code></pre>
<blockquote>
<p><font color="red">要尤其注意for循环后的index值,是先变化值,再进行判断</font></p>
</blockquote>
<h2 id="水果成篮"><a href="#水果成篮" class="headerlink" title="水果成篮"></a>水果成篮</h2><blockquote>
<p>题目链接 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fruit-into-baskets/">leetcode</a></p>
</blockquote>
<p>&#x2F;&#x2F;TODO</p>
<h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><blockquote>
<p>题目链接 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">leetcode</a></p>
</blockquote>
<p>&#x2F;&#x2F;TODO</p>
<h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><blockquote>
<p>题目链接 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/">leetcode</a></p>
</blockquote>
<p>&#x2F;&#x2F;TODO</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-03-20T10:45:20.000Z" itemprop="datePublished">2023-03-20</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-SNPE-Snapdragon神经处理引擎部署"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/03/17/SNPE-Snapdragon%E7%A5%9E%E7%BB%8F%E5%A4%84%E7%90%86%E5%BC%95%E6%93%8E%E9%83%A8%E7%BD%B2/">SNPE-Snapdragon神经处理引擎部署</a>
    </header>
    <div class="article-entry post-inner-html">
        
        
        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-03-17T13:42:10.000Z" itemprop="datePublished">2023-03-17</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-1"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/03/16/%E7%AE%97%E6%B3%95-day-1/">算法 | day 1</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <blockquote>
<p>本文参考自 <a target="_blank" rel="noopener" href="https://programmercarl.com/">代码随想录</a></p>
</blockquote>
<h2 id="数组基础"><a href="#数组基础" class="headerlink" title="数组基础"></a>数组基础</h2><p>数组是存放在连续内存空间上的相同类型数据的集合</p>
<p>需要两点注意的是:</p>
<ul>
<li>数组下标都是从0开始的</li>
<li>数组内存空间的地址是连续的</li>
</ul>
<p><strong>因为数组的在内存空间的地址是连续的,所以我们在删除或者增添元素的时候,就难免要移动其他元素的地址.数组的元素是不能删的,只能覆盖.</strong></p>
<p>在C++中二维数组是连续分布的</p>
<p>测试:</p>
<pre><code class="c++">void test_arr() &#123;
    int array[2][3] = &#123;
        &#123;0, 1, 2&#125;,
        &#123;3, 4, 5&#125;
    &#125;;
    cout &lt;&lt; &amp;array[0][0] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[0][1] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[0][2] &lt;&lt; endl;
    cout &lt;&lt; &amp;array[1][0] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[1][1] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[1][2] &lt;&lt; endl;
&#125;

int main() &#123;
    test_arr();
&#125;
</code></pre>
<p>结果:</p>
<pre><code>0x20d4dffc90 0x20d4dffc94 0x20d4dffc98
0x20d4dffc9c 0x20d4dffca0 0x20d4dffca4
</code></pre>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target,写一个函数搜索 nums 中的 target,如果目标值存在返回下标,否则返回 -1</p>
<p>示例 1:</p>
<pre><code class="bash">输入: nums = [-1,0,3,5,9,12], target = 9     
输出: 4       
解释: 9 出现在 nums 中并且下标为 4     
</code></pre>
<p>示例 2:</p>
<pre><code class="bash">输入: nums = [-1,0,3,5,9,12], target = 2     
输出: -1        
解释: 2 不存在 nums 中因此返回 -1     
</code></pre>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    int search(vector&lt;int&gt;&amp; nums, int target) &#123;
        int low=0;
        int high=nums.size()-1;
        while(high&gt;=low)&#123;
            int mid=low+(high-low)/2;
            if(nums[mid]&gt;target)&#123;
                high=mid-1;
            &#125;else if(nums[mid]&lt;target)&#123;
                low=mid+1;
            &#125;else&#123;
                return mid;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;
</code></pre>
<p>这道题目的前提是数组为有序数组,同时题目还强调数组中无重复元素,因为一旦有重复元素,使用二分查找法返回的元素下标可能不是唯一的.</p>
<p>二分查找涉及的很多的边界条件,逻辑比较简单.但较容易分不清到底是 while(left &lt; right) 还是 while(left &lt;&#x3D; right),到底是right &#x3D; middle呢,还是要right &#x3D; middle - 1.</p>
<p>写二分法,区间的定义一般为两种,左闭右闭即[left, right],或者左闭右开即[left, right).</p>
<p>例子如下:</p>
<pre><code class="C++">// 版本一
class Solution &#123;
public:
    int search(vector&lt;int&gt;&amp; nums, int target) &#123;
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里,[left, right]
        while (left &lt;= right) &#123; // 当left==right,区间[left, right]依然有效,所以用 &lt;=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] &gt; target) &#123;
                right = middle - 1; // target 在左区间,所以[left, middle - 1]
            &#125; else if (nums[middle] &lt; target) &#123;
                left = middle + 1; // target 在右区间,所以[middle + 1, right]
            &#125; else &#123; // nums[middle] == target
                return middle; // 数组中找到目标值,直接返回下标
            &#125;
        &#125;
        // 未找到目标值
        return -1;
    &#125;
&#125;;
</code></pre>
<pre><code class="C++">// 版本二
class Solution &#123;
public:
    int search(vector&lt;int&gt;&amp; nums, int target) &#123;
        int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里,即:[left, right)
        while (left &lt; right) &#123; // 因为left == right的时候,在[left, right)是无效的空间,所以使用 &lt;
            int middle = left + ((right - left) &gt;&gt; 1);
            if (nums[middle] &gt; target) &#123;
                right = middle; // target 在左区间,在[left, middle)中
            &#125; else if (nums[middle] &lt; target) &#123;
                left = middle + 1; // target 在右区间,在[middle + 1, right)中
            &#125; else &#123; // nums[middle] == target
                return middle; // 数组中找到目标值,直接返回下标
            &#125;
        &#125;
        // 未找到目标值
        return -1;
    &#125;
&#125;;
</code></pre>
<h2 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h2><p>给定一个排序数组和一个目标值,在数组中找到目标值,并返回其索引.如果目标值不存在于数组中,返回它将会被按顺序插入的位置.</p>
<p>你可以假设数组中无重复元素.</p>
<p>示例 1:</p>
<ul>
<li><p>输入: [1,3,5,6], 5</p>
</li>
<li><p>输出: 2</p>
</li>
<li><p>示例 2:</p>
</li>
<li><p>输入: [1,3,5,6], 2</p>
</li>
<li><p>输出: 1</p>
</li>
</ul>
<p>示例 3:</p>
<ul>
<li>输入: [1,3,5,6], 7</li>
<li>输出: 4</li>
</ul>
<p>示例 4:</p>
<ul>
<li>输入: [1,3,5,6], 0</li>
<li>输出: 0</li>
</ul>
<p><font color="red">未提交</font></p>
<p>这题target插入有四种情况:</p>
<ul>
<li>target在数组所有元素之前</li>
<li>target等于数组中某一个元素</li>
<li>target插入数组中的位置</li>
<li>target在数组所有元素之后</li>
</ul>
<p>二分查找(左闭右闭区间)如果一直没找到相等值,最终一定会 <code>low=high-1</code> -&gt; <code>low=high</code></p>
<p>当<code>low=high</code>时</p>
<ul>
<li><code>target&lt;nums[mid]</code> -&gt; <code>high=mid-1</code>,即<code>high=low-1</code>,返回low、high+1</li>
<li><code>target&gt;nums[mid]</code> -&gt; <code>low=mid+1</code> ,即<code>low=high+1</code>,返回low、high+1</li>
</ul>
<p>例子:</p>
<pre><code class="C++">class Solution &#123;
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;
        int n = nums.size();
        int left = 0;
        int right = n - 1; // 定义target在左闭右闭的区间里,[left, right]
        while (left &lt;= right) &#123; // 当left==right,区间[left, right]依然有效
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] &gt; target) &#123;
                right = middle - 1; // target 在左区间,所以[left, middle - 1]
            &#125; else if (nums[middle] &lt; target) &#123;
                left = middle + 1; // target 在右区间,所以[middle + 1, right]
            &#125; else &#123; // nums[middle] == target
                return middle;
            &#125;
        &#125;
        // 分别处理如下四种情况
        // 目标值在数组所有元素之前  [0, -1]
        // 目标值等于数组中某一个元素  return middle;
        // 目标值插入数组中的位置 [left, right],return  right + 1
        // 目标值在数组所有元素之后的情况 [left, right], 因为是右闭区间,所以 return right + 1
        return right + 1;
    &#125;
&#125;;
</code></pre>
<pre><code class="C++">class Solution &#123;
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;
        int n = nums.size();
        int left = 0;
        int right = n; // 定义target在左闭右开的区间里,[left, right)  target
        while (left &lt; right) &#123; // 因为left == right的时候,在[left, right)是无效的空间
            int middle = left + ((right - left) &gt;&gt; 1);
            if (nums[middle] &gt; target) &#123;
                right = middle; // target 在左区间,在[left, middle)中
            &#125; else if (nums[middle] &lt; target) &#123;
                left = middle + 1; // target 在右区间,在 [middle+1, right)中
            &#125; else &#123; // nums[middle] == target
                return middle; // 数组中找到目标值的情况,直接返回下标
            &#125;
        &#125;
        // 分别处理如下四种情况
        // 目标值在数组所有元素之前 [0,0)
        // 目标值等于数组中某一个元素 return middle
        // 目标值插入数组中的位置 [left, right) ,return right 即可
        // 目标值在数组所有元素之后的情况 [left, right),因为是右开区间,所以 return right
        return right;
    &#125;
&#125;;
</code></pre>
<h2 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h2><p>给你一个按照非递减顺序排列的整数数组 nums,和一个目标值 target.请你找出给定目标值在数组中的开始位置和结束位置.</p>
<p>如果数组中不存在目标值 target,返回 [-1, -1].</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题.</p>
<p>示例 1:</p>
<pre><code class="bash">输入:nums = [5,7,7,8,8,10], target = 8
输出:[3,4]
</code></pre>
<p>示例 2:</p>
<pre><code class="bash">输入:nums = [5,7,7,8,8,10], target = 6
输出:[-1,-1]
</code></pre>
<p>示例 3:</p>
<pre><code class="bash">输入:nums = [], target = 0
输出:[-1,-1]
</code></pre>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;
        int low=0;
        int high=nums.size()-1;
        int mid=search(nums,target,low,high);
        if(mid==-1)&#123;
            return &#123;-1,-1&#125;;
        &#125;
        int right=mid,left=mid;
        //注意可以在循环括号中赋值并判断,但不能初始化(重复初始化)
        //重复计算,每次二分查找low都为0
        while((mid=search(nums,target,low,left-1))!=-1)&#123;
            left=mid;
        &#125;
        while((mid=search(nums,target,right + 1, high))!=-1)&#123;
            right=mid;
        &#125;
        return &#123;left,right&#125;;
    &#125;

    int search(vector&lt;int&gt;&amp; nums, int target,int low,int high) &#123;
        while(high&gt;=low)&#123;
            int mid=low+(high-low)/2;
            if(nums[mid]&gt;target)&#123;
                high=mid-1;
            &#125;else if(nums[mid]&lt;target)&#123;
                low=mid+1;
            &#125;else&#123;
                return mid;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;
</code></pre>
<p>思路先做一次二分查找,再不断向左向右二分查找,直到找不到值.</p>
<p><font color="red">但是代码有重复计算,每次二分查找都是low&#x3D;0或者high&#x3D;nums.size()-1,实际上,在循环过程中,因为上次循环计算过low和high,下次循环应该从上次计算的边界开始.</font></p>
<p><font color="red">leetcode优质回答:</font></p>
<pre><code class="C++">class Solution &#123;
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;
        return &#123;find(nums, target, true), find(nums, target, false)&#125;;
    &#125;

    int find(vector&lt;int&gt; nums, int target, bool minType) &#123;
        int left = 0, right = nums.size() - 1;
        int ans = -1;
        while (left &lt;= right) &#123;
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) &#123;
                //只有在相等的时候才更新边界!
                ans = mid;
                if (minType) &#123;
                    right = mid - 1;
                &#125; else &#123;
                    left = mid + 1;
                &#125;
            &#125; else if (target &lt; nums[mid]) &#123;
                right = mid - 1;
            &#125; else &#123;
                left = mid + 1;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
<p>寻找target在数组里的左右边界,有如下三种情况:</p>
<ul>
<li><p>情况一:target 在数组范围的右边或者左边,例如数组{3, 4, 5},target为2或者数组{3, 4, 5},target为6,此时应该返回{-1, -1}</p>
</li>
<li><p>情况二:target 在数组范围中,且数组中不存在target,例如数组{3,6,7},target为5,此时应该返回{-1, -1}</p>
</li>
<li><p>情况三:target 在数组范围中,且数组中存在target,例如数组{3,6,7},target为6,此时应该返回{1, 1}</p>
</li>
</ul>
<p>示例代码:</p>
<pre><code class="C++">class Solution &#123;
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;
        int leftBorder = getLeftBorder(nums, target);
        int rightBorder = getRightBorder(nums, target);
        // 情况一
        if (leftBorder == -2 || rightBorder == -2) return &#123;-1, -1&#125;;
        // 情况三
        if (rightBorder - leftBorder &gt; 1) return &#123;leftBorder + 1, rightBorder - 1&#125;;
        // 情况二
        return &#123;-1, -1&#125;;
    &#125;
private:
     int getRightBorder(vector&lt;int&gt;&amp; nums, int target) &#123;
        int left = 0;
        int right = nums.size() - 1;
        int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况
        while (left &lt;= right) &#123;
            int middle = left + ((right - left) / 2);
            if (nums[middle] &gt; target) &#123;
                right = middle - 1;
            &#125; else &#123; // 寻找右边界,nums[middle] == target的时候更新left
                left = middle + 1;
                rightBorder = left;
            &#125;
        &#125;
        return rightBorder;
    &#125;
    int getLeftBorder(vector&lt;int&gt;&amp; nums, int target) &#123;
        int left = 0;
        int right = nums.size() - 1;
        int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况
        while (left &lt;= right) &#123;
            int middle = left + ((right - left) / 2);
            if (nums[middle] &gt;= target) &#123; // 寻找左边界,nums[middle] == target的时候更新right
                right = middle - 1;
                leftBorder = right;
            &#125; else &#123;
                left = middle + 1;
            &#125;
        &#125;
        return leftBorder;
    &#125;
&#125;;
</code></pre>
<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>给你一个数组 nums 和一个值 val,你需要 原地 移除所有数值等于 val 的元素,并返回移除后数组的新长度.</p>
<p>不要使用额外的数组空间,你必须仅使用 O(1) 额外空间并原地修改输入数组.</p>
<p>元素的顺序可以改变.你不需要考虑数组中超出新长度后面的元素.</p>
<p>示例 1: 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2. 你不需要考虑数组中超出新长度后面的元素.</p>
<p>示例 2: 给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4.</p>
<p>你不需要考虑数组中超出新长度后面的元素.</p>
<p>leetcode提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;
        if(nums.size()==0)&#123;
            return 0;
        &#125;
        int slow=0,fast=0;
        while(slow&lt;nums.size()&amp;&amp;nums[slow]!=val)&#123;
            slow++;
            fast++;
        &#125;
        for(;fast&lt;nums.size();fast++)&#123;
            if(nums[fast]==val)&#123;
                continue;
            &#125;else&#123;
                nums[slow]=nums[fast];
                slow++;
            &#125;
        &#125;
        return slow;
    &#125;
&#125;;
</code></pre>
<p>例子:</p>
<pre><code class="C++">class Solution &#123;
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex &lt; nums.size(); fastIndex++) &#123;
            if (val != nums[fastIndex]) &#123;
                nums[slowIndex++] = nums[fastIndex];
            &#125;
        &#125;
        return slowIndex;
    &#125;
&#125;;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-03-16T10:07:27.000Z" itemprop="datePublished">2023-03-16</time>
</div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-hello-world"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/03/16/hello-world/">Hello World</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-03-16T05:54:35.612Z" itemprop="datePublished">2023-03-16</time>
</div>
    
    
    </div>
</footer>

</article>

    
  

  
</div>

                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
    
      

    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2023/03/20/%E7%AE%97%E6%B3%95-day-2/">算法 | day 2</a>
          </li>
        
          <li>
            <a href="/2023/03/17/SNPE-Snapdragon%E7%A5%9E%E7%BB%8F%E5%A4%84%E7%90%86%E5%BC%95%E6%93%8E%E9%83%A8%E7%BD%B2/">SNPE-Snapdragon神经处理引擎部署</a>
          </li>
        
          <li>
            <a href="/2023/03/16/%E7%AE%97%E6%B3%95-day-1/">算法 | day 1</a>
          </li>
        
          <li>
            <a href="/2023/03/16/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            Hexo &copy; 2023<br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>

<script type="module" src="https://unpkg.com/ionicons@6.0.2/dist/ionicons/ionicons.esm.js"></script>






<script src="/dist/build.js?1654266144177.js"></script>


<script src="/dist/custom.js?1654266144177.js"></script>













</body>

</html>