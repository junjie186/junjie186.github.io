<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>Hexo</title>

    <meta name="description" content="Hexo">
    <meta name="keywords" content="">

    



    <meta property="og:type" content="website"/>
    <meta property="og:title" content=""/>
    <meta property="og:description" content=""/>
    <meta property="og:locale" content="cn" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="http://example.com/index.html" />
    <meta property="og:site_name" content="John Doe" />
    <meta property="article:publisher" content="" />
    <script type="application/ld+json">
        {
            "@context": "https://schema.org",
            "@type": "WebPage",
            "name": "",
            "description": "",
            "publisher": {
                "@type": "Organization",
                "name": "John Doe"
            },
        }
    </script>


    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1654266144177.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1654266144177.css">


    <script>
        window.isPost = false
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/avatar.jpg" alt="John Doe">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>Hexo</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="index">
  
    
      <article
id="post-算法-day-34"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-34/">算法 | day 34</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="K-次取反后最大化的数组和、"><a href="#K-次取反后最大化的数组和、" class="headerlink" title="K 次取反后最大化的数组和、"></a>K 次取反后最大化的数组和、</h2><p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p>
<p>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。<br>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。</p>
<p>以这种方式修改数组后，返回数组 可能的最大和 。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：nums = [4,2,3], k = 1
输出：5
解释：选择下标 1 ，nums 变为 [4,-2,3] 。
</code></pre>
<p>代码:</p>
<pre><code class="C++">class Solution &#123;
static bool cmp(int a, int b) &#123;
    return abs(a) &gt; abs(b);
&#125;
public:
    int largestSumAfterKNegations(vector&lt;int&gt;&amp; A, int K) &#123;
        sort(A.begin(), A.end(), cmp);       // 第一步
        for (int i = 0; i &lt; A.size(); i++) &#123; // 第二步
            if (A[i] &lt; 0 &amp;&amp; K &gt; 0) &#123;
                A[i] *= -1;
                K--;
            &#125;
        &#125;
        if (K % 2 == 1) A[A.size() - 1] *= -1; // 第三步
        int result = 0;
        for (int a : A) result += a;        // 第四步
        return result;
    &#125;
&#125;;
</code></pre>
<h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p>
<p>示例 1:</p>
<pre><code class="bash">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
</code></pre>
<p>没想出来…</p>
<p>思路:贪心,从某一点开始,一直计算往下计算需要油量,如果油量小于0则从下一点开始,那么有没有可能在这中间的点是正确结果呢?不可能,这个中间节点的前部分油和大于0,从左点都走不到结尾,中间点更不可能走到.</p>
<pre><code class="C++">class Solution &#123;
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;
        int curSum = 0;
        int totalSum = 0;
        int start = 0;
        for (int i = 0; i &lt; gas.size(); i++) &#123;
            curSum += gas[i] - cost[i];
            totalSum += gas[i] - cost[i];
            if (curSum &lt; 0) &#123;   // 当前累加rest[i]和 curSum一旦小于0
                start = i + 1;  // 起始位置更新为i+1
                curSum = 0;     // curSum从0开始
            &#125;
        &#125;
        if (totalSum &lt; 0) return -1; // 说明怎么走都不可能跑一圈了
        return start;
    &#125;
&#125;;
</code></pre>
<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
</code></pre>
<p>示例 2：</p>
<pre><code class="bash">输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
</code></pre>
<p>代码:</p>
<pre><code class="C++">class Solution &#123;
public:
    int candy(vector&lt;int&gt;&amp; ratings) &#123;
        vector&lt;int&gt; candyVec(ratings.size(), 1);
        // 从前向后
        for (int i = 1; i &lt; ratings.size(); i++) &#123;
            if (ratings[i] &gt; ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1;
        &#125;
        // 从后向前
        for (int i = ratings.size() - 2; i &gt;= 0; i--) &#123;
            if (ratings[i] &gt; ratings[i + 1] ) &#123;
                candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1);
            &#125;
        &#125;
        // 统计结果
        int result = 0;
        for (int i = 0; i &lt; candyVec.size(); i++) result += candyVec[i];
        return result;
    &#125;
&#125;;
</code></pre>
<p>思路:先从前往后遍历再从后往前遍历. 不需要考虑相等的情况,因为如果一个孩子评分左右相等的话,那他得一个糖果,如果左右两边有一个不等的话,那就是前后遍历要考虑的了.</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-23T10:41:03.000Z" itemprop="datePublished">2023-04-23</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-32"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-32/">算法 | day 32</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h2><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p>
<p>返回 你能获得的 最大 利润 。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
</code></pre>
<p>示例 2：</p>
<pre><code class="bash">输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
</code></pre>
<p>思路:所有上升序列的差值和即为最大收益.</p>
<pre><code class="C++">class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
        int max=0;
        int tmp=prices[0];
        for(int i=1;i&lt;prices.size();i++)&#123;
            if(prices[i]&gt;tmp)&#123;
                max+=prices[i]-tmp;
            &#125;
            tmp=prices[i];
        &#125;
        return max;
    &#125;
&#125;;
</code></pre>
<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
</code></pre>
<p>示例 2：</p>
<pre><code class="bash">输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
</code></pre>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    bool canJump(vector&lt;int&gt;&amp; nums) &#123;
        if(nums.size()==1)&#123;
            return true;
        &#125;
        int length=nums[0]+1;
        for(int i=1;i&lt;length;i++)&#123;
            if(i+1+nums[i]&gt;length)&#123;
                length=i+1+nums[i];
            &#125;
            if(length&gt;=nums.size())&#123;
                return true;
            &#125;   
        &#125;

        return false;
    &#125;
&#125;;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-23T10:40:38.000Z" itemprop="datePublished">2023-04-23</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-31"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-31/">算法 | day 31</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>示例 1:</p>
<pre><code class="bash">输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
</code></pre>
<p>示例 2:</p>
<pre><code>输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
</code></pre>
<p>思路:直觉是,先分配最大的饼干给最大胃口的孩子,一直往小分配.</p>
<pre><code class="C++">class Solution &#123;
public:
    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int k=g.size()-1;
        int num=0;;
        for(int i=s.size()-1;i&gt;=0;i--)&#123;
            for(;k&gt;=0;k--)&#123;
                if(s[i]&gt;=g[k])&#123;
                    num++;
                    k--;
                    break;
                &#125;
            &#125;
        &#125;
        return num;
    &#125;
&#125;;
</code></pre>
<h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p>
<p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
</code></pre>
<p>示例 2：</p>
<pre><code class="bash">输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
</code></pre>
<p>没想出来…</p>
<p>贪心算法:</p>
<pre><code class="C++">class Solution &#123;
public:
    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;
        if (nums.size() &lt;= 1) return nums.size();
        int curDiff = 0; // 当前一对差值
        int preDiff = 0; // 前一对差值
        int result = 1;  // 记录峰值个数，序列默认序列最右边有一个峰值
        for (int i = 0; i &lt; nums.size() - 1; i++) &#123;
            curDiff = nums[i + 1] - nums[i];
            // 出现峰值
            if ((preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0)) &#123;
                result++;
                preDiff = curDiff; // 注意这里，只在摆动变化的时候更新prediff 
            &#125;
        &#125;
        return result;
    &#125;
&#125;;
</code></pre>
<p>动态规划:</p>
<ul>
<li>设dp状态dp[i][0]，表示考虑前i个数，第i个数作为山峰的摆动子序列的最长长度</li>
<li>设dp状态dp[i][1]，表示考虑前i个数，第i个数作为山谷的摆动子序列的最长长度</li>
</ul>
<p>则转移方程为：</p>
<ul>
<li>dp[i][0] &#x3D; max(dp[i][0], dp[j][1] + 1)，其中0 &lt; j &lt; i且nums[j] &lt; nums[i]，表示将nums[i]接到前面某个山谷后面，作为山峰。</li>
<li>dp[i][1] &#x3D; max(dp[i][1], dp[j][0] + 1)，其中0 &lt; j &lt; i且nums[j] &gt; nums[i]，表示将nums[i]接到前面某个山峰后面，作为山谷。</li>
</ul>
<pre><code class="C++">class Solution &#123;
public:
    int dp[1005][2];
    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;
        memset(dp, 0, sizeof dp);
        dp[0][0] = dp[0][1] = 1;
        for (int i = 1; i &lt; nums.size(); ++i) &#123;
            dp[i][0] = dp[i][1] = 1;
            for (int j = 0; j &lt; i; ++j) &#123;
                if (nums[j] &gt; nums[i]) dp[i][1] = max(dp[i][1], dp[j][0] + 1);
            &#125;
            for (int j = 0; j &lt; i; ++j) &#123;
                if (nums[j] &lt; nums[i]) dp[i][0] = max(dp[i][0], dp[j][1] + 1);
            &#125;
        &#125;
        return max(dp[nums.size() - 1][0], dp[nums.size() - 1][1]);
    &#125;
&#125;;
</code></pre>
<p>更简单的动态规划:</p>
<p>每当我们选择一个元素作为摆动序列的一部分时，这个元素要么是上升的，要么是下降的，这取决于前一个元素的大小。那么列出状态表达式为：</p>
<ul>
<li><p>up[i] 表示以前 i 个元素中的某一个为结尾的最长的「上升摆动序列」的长度。</p>
</li>
<li><p>down[i] 表示以前 i 个元素中的某一个为结尾的最长的「下降摆动序列」的长度。</p>
</li>
</ul>
<p>则转移方程为:</p>
<p><img src="/./%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B.png"></p>
<p>代码:</p>
<pre><code class="C++">class Solution &#123;
public:
    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;
        int n = nums.size();
        if (n &lt; 2) &#123;
            return n;
        &#125;
        vector&lt;int&gt; up(n), down(n);
        up[0] = down[0] = 1;
        for (int i = 1; i &lt; n; i++) &#123;
            if (nums[i] &gt; nums[i - 1]) &#123;
                up[i] = max(up[i - 1], down[i - 1] + 1);
                down[i] = down[i - 1];
            &#125; else if (nums[i] &lt; nums[i - 1]) &#123;
                up[i] = up[i - 1];
                down[i] = max(up[i - 1] + 1, down[i - 1]);
            &#125; else &#123;
                up[i] = up[i - 1];
                down[i] = down[i - 1];
            &#125;
        &#125;
        return max(up[n - 1], down[n - 1]);
    &#125;
&#125;;
</code></pre>
<h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组 是数组中的一个连续部分。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
</code></pre>
<p>示例 2：</p>
<pre><code class="bash">输入：nums = [1]
输出：1
</code></pre>
<p>思路:数组从头开始加,如果sum小于0了,则重新设置sum为0.</p>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;
        int max=INT_MIN;
        int sum=0;
        for(int i=0;i&lt;nums.size();i++)&#123;
            sum+=nums[i];
            if(sum&gt;max)&#123;
                max=sum;
            &#125;
            if(sum&lt;0)&#123;
                sum=0;
            &#125;
        &#125;

        return max;
    &#125;
&#125;;
</code></pre>
<p>动态规划,设dp[i]为以第i个数结尾的最大子序列之和.</p>
<pre><code class="C++">class Solution &#123;
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;
        int dp[nums.size()];
        dp[0]=nums[0];
        int max=dp[0];
        for(int i=1;i&lt;nums.size();i++)&#123;
            if(dp[i-1]&gt;=0)&#123;
                dp[i]=dp[i-1]+nums[i];
            &#125;else&#123;
                dp[i]=nums[i];
            &#125;
            if(dp[i]&gt;max)&#123;
                max=dp[i];
            &#125;
        &#125;
        return max;
    &#125;
&#125;;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-23T10:40:20.000Z" itemprop="datePublished">2023-04-23</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-30"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-30/">算法 | day 30</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程</h2><p>给你一份航线列表 tickets ，其中 tickets[i] &#x3D; [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p>
<p>所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p>
<p>例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前。<br>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：tickets = [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]
输出：[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]
</code></pre>
<p>示例 2：</p>
<pre><code class="bash">输入：tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]
输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]
解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。
</code></pre>
<p>直接上代码以后慢慢看吧…</p>
<pre><code class="C++">class Solution &#123;
private:
// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets
unordered_map&lt;string, map&lt;string, int&gt;&gt; targets;
bool backtracking(int ticketNum, vector&lt;string&gt;&amp; result) &#123;
    if (result.size() == ticketNum + 1) &#123;
        return true;
    &#125;
    for (pair&lt;const string, int&gt;&amp; target : targets[result[result.size() - 1]]) &#123;
        if (target.second &gt; 0 ) &#123; // 记录到达机场是否飞过了
            result.push_back(target.first);
            target.second--;
            if (backtracking(ticketNum, result)) return true;
            result.pop_back();
            target.second++;
        &#125;
    &#125;
    return false;
&#125;
public:
    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;
        targets.clear();
        vector&lt;string&gt; result;
        for (const vector&lt;string&gt;&amp; vec : tickets) &#123;
            targets[vec[0]][vec[1]]++; // 记录映射关系
        &#125;
        result.push_back(&quot;JFK&quot;); // 起始机场
        backtracking(tickets.size(), result);
        return result;
    &#125;
&#125;;
</code></pre>
<h2 id="N-皇后"><a href="#N-皇后" class="headerlink" title="N 皇后"></a>N 皇后</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：n = 4
输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
</code></pre>
<p>示例 2：</p>
<pre><code class="bash">输入：n = 1
输出：[[&quot;Q&quot;]]
</code></pre>
<p>思路:这题相对简单,使用places数组记录不能填的位置.</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;vector&lt;string&gt;&gt; result;
public:
    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;
        vector&lt;int&gt; nums;
        vector&lt;string&gt; path;
        backtracking(n,nums,path,0);
        return result;
    &#125;

    void backtracking(int n,vector&lt;int&gt;&amp; nums,vector&lt;string&gt;&amp; path,int k)&#123;
        if(k==n)&#123;
            result.push_back(path);
            return;
        &#125;
        vector&lt;bool&gt; places(n,true);
        for(int i=0;i&lt;nums.size();i++)&#123;
            places[nums[i]]=false;
            if(nums[i]-k+i&gt;=0)&#123;
                places[nums[i]-k+i]=false;
            &#125;
            if(nums[i]+k-i&lt;n)&#123;
                places[nums[i]+k-i]=false;
            &#125;
        &#125;
        for(int i=0;i&lt;n;i++)&#123;
            if(!places[i])&#123;
                continue;
            &#125;
            string s(n-1,&#39;.&#39;);
            s.insert(i,1,&#39;Q&#39;);
            nums.push_back(i);
            path.push_back(s);
            backtracking(n,nums,path,k+1);
            path.pop_back();
            nums.pop_back();
        &#125;
    &#125;
&#125;;
</code></pre>
<p>注意一下 string 的insert方法.</p>
<h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h2><p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 遵循如下规则：</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<pre><code class="C++">class Solution &#123;
private:
bool backtracking(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;
    for (int i = 0; i &lt; board.size(); i++) &#123;        // 遍历行
        for (int j = 0; j &lt; board[0].size(); j++) &#123; // 遍历列
            if (board[i][j] == &#39;.&#39;) &#123;
                for (char k = &#39;1&#39;; k &lt;= &#39;9&#39;; k++) &#123;     // (i, j) 这个位置放k是否合适
                    if (isValid(i, j, k, board)) &#123;
                        board[i][j] = k;                // 放置k
                        if (backtracking(board)) return true; // 如果找到合适一组立刻返回
                        board[i][j] = &#39;.&#39;;              // 回溯，撤销k
                    &#125;
                &#125;
                return false;  // 9个数都试完了，都不行，那么就返回false
            &#125;
        &#125;
    &#125;
    return true; // 遍历完没有返回false，说明找到了合适棋盘位置了
&#125;
bool isValid(int row, int col, char val, vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;
    for (int i = 0; i &lt; 9; i++) &#123; // 判断行里是否重复
        if (board[row][i] == val) &#123;
            return false;
        &#125;
    &#125;
    for (int j = 0; j &lt; 9; j++) &#123; // 判断列里是否重复
        if (board[j][col] == val) &#123;
            return false;
        &#125;
    &#125;
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for (int i = startRow; i &lt; startRow + 3; i++) &#123; // 判断9方格里是否重复
        for (int j = startCol; j &lt; startCol + 3; j++) &#123;
            if (board[i][j] == val ) &#123;
                return false;
            &#125;
        &#125;
    &#125;
    return true;
&#125;
public:
    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;
        backtracking(board);
    &#125;
&#125;;
</code></pre>
<p>思路:在回溯中使用二维遍历放棋子,单独判断这个位置能不能放.</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-23T10:39:41.000Z" itemprop="datePublished">2023-04-23</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-28"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-28/">算法 | day 28</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="复原-IP-地址"><a href="#复原-IP-地址" class="headerlink" title="复原 IP 地址"></a>复原 IP 地址</h2><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#49;&#x39;&#50;&#x2e;&#49;&#x36;&#56;&#64;&#x31;&#x2e;&#x31;">&#49;&#x39;&#50;&#x2e;&#49;&#x36;&#56;&#64;&#x31;&#x2e;&#x31;</a>“ 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：s = &quot;25525511135&quot;
输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]
</code></pre>
<p>示例 2：</p>
<pre><code class="bash">输入：s = &quot;0000&quot;
输出：[&quot;0.0.0.0&quot;]
</code></pre>
<p>示例 3：</p>
<pre><code class="bash">输入：s = &quot;101023&quot;
输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]
</code></pre>
<p>没写出来…</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;string&gt; result;// 记录结果
    // startIndex: 搜索的起始位置，pointNum:添加逗点的数量
    void backtracking(string&amp; s, int startIndex, int pointNum) &#123;
        if (pointNum == 3) &#123; // 逗点数量为3时，分隔结束
            // 判断第四段子字符串是否合法，如果合法就放进result中
            if (isValid(s, startIndex, s.size() - 1)) &#123;
                result.push_back(s);
            &#125;
            return;
        &#125;
        for (int i = startIndex; i &lt; s.size(); i++) &#123;
            if (isValid(s, startIndex, i)) &#123; // 判断 [startIndex,i] 这个区间的子串是否合法
                s.insert(s.begin() + i + 1 , &#39;.&#39;);  // 在i的后面插入一个逗点
                pointNum++;
                backtracking(s, i + 2, pointNum);   // 插入逗点之后下一个子串的起始位置为i+2
                pointNum--;                         // 回溯
                s.erase(s.begin() + i + 1);         // 回溯删掉逗点
            &#125; else break; // 不合法，直接结束本层循环
        &#125;
    &#125;
    // 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法
    bool isValid(const string&amp; s, int start, int end) &#123;
        if (start &gt; end) &#123;
            return false;
        &#125;
        if (s[start] == &#39;0&#39; &amp;&amp; start != end) &#123; // 0开头的数字不合法
                return false;
        &#125;
        int num = 0;
        for (int i = start; i &lt;= end; i++) &#123;
            if (s[i] &gt; &#39;9&#39; || s[i] &lt; &#39;0&#39;) &#123; // 遇到非数字字符不合法
                return false;
            &#125;
            num = num * 10 + (s[i] - &#39;0&#39;);
            if (num &gt; 255) &#123; // 如果大于255了不合法
                return false;
            &#125;
        &#125;
        return true;
    &#125;
public:
    vector&lt;string&gt; restoreIpAddresses(string s) &#123;
        result.clear();
        if (s.size() &lt; 4 || s.size() &gt; 12) return result; // 算是剪枝了
        backtracking(s, 0, 0);
        return result;
    &#125;
&#125;;
</code></pre>
<h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
</code></pre>
<p>示例 2：</p>
<pre><code class="bash">输入：nums = [0]
输出：[[],[0]]
</code></pre>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
    vector&lt;vector&lt;int&gt;&gt; result;
public:
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;int&gt; path;
        path.clear();
        result.clear();
        result.push_back(path);
        backtracking(nums,0,path);
        return result;
    &#125;

    void backtracking(vector&lt;int&gt;&amp; nums,int start,vector&lt;int&gt;&amp; path)&#123;
        for(int i=start;i&lt;nums.size();i++)&#123;
            path.push_back(nums[i]);
            result.push_back(path);
            backtracking(nums,i+1,path);
            path.pop_back();
        &#125;
    &#125;
&#125;;
</code></pre>
<h2 id="子集-II"><a href="#子集-II" class="headerlink" title="子集 II"></a>子集 II</h2><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]  
</code></pre>
<p>示例 2：</p>
<pre><code class="bash">输入：nums = [0]
输出：[[],[0]]
</code></pre>
<p>思路: sort 再同一层去重</p>
<pre><code class="C++">class Solution &#123;
    vector&lt;vector&lt;int&gt;&gt; result;
public:
    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;int&gt; path;
        path.clear();
        result.clear();
        result.push_back(path);
        sort(nums.begin(),nums.end());
        backtracking(nums,0,path);
        return result;
    &#125;

    void backtracking(vector&lt;int&gt;&amp; nums,int start,vector&lt;int&gt;&amp; path)&#123;
        int pre=-11;
        for(int i=start;i&lt;nums.size();i++)&#123;
            if(nums[i]==pre)&#123;
                continue;
            &#125;
            path.push_back(nums[i]);
            result.push_back(path);
            backtracking(nums,i+1,path);
            path.pop_back();
            pre=nums[i];
        &#125;
    &#125;
&#125;;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-23T10:37:44.000Z" itemprop="datePublished">2023-04-23</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-27"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-27/">算法 | day 27</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
</code></pre>
<p>没写出来…</p>
<p>例子:</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void backtracking(vector&lt;int&gt;&amp; candidates, int target, int sum, int startIndex) &#123;
        if (sum == target) &#123;
            result.push_back(path);
            return;
        &#125;

        // 如果 sum + candidates[i] &gt; target 就终止遍历
        for (int i = startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i);
            sum -= candidates[i];
            path.pop_back();

        &#125;
    &#125;
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;
        result.clear();
        path.clear();
        sort(candidates.begin(), candidates.end()); // 需要排序
        backtracking(candidates, target, 0, 0);
        return result;
    &#125;
&#125;;
</code></pre>
<p>实际上不难 <code>backtracking(candidates, target, sum, i);</code> 就重复利用了所有元素.<br>先将数组sort方便了剪枝.</p>
<h2 id="组合总和-II"><a href="#组合总和-II" class="headerlink" title="组合总和 II"></a>组合总和 II</h2><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用 一次 。</p>
<p>注意：解集不能包含重复的组合。 </p>
<p>示例 1:</p>
<pre><code class="bash">输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
</code></pre>
<p>示例 2:</p>
<pre><code class="bash">输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
</code></pre>
<p>思路 有重复元素就要考虑去重,先<code>sort</code>,在看当前元素是不是和前一个元素相同.</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;
        vector&lt;int&gt; nums;
        nums.clear();
        result.clear();
        sort(candidates.begin(),candidates.end());
        backtracking(candidates,target,nums,0);
        return result;
    &#125;

    void backtracking(vector&lt;int&gt;&amp; candidates, int target,vector&lt;int&gt;&amp; nums,int start)&#123;
        if(target==0)&#123;
            result.push_back(nums);
        &#125;
        int pre=0;
        for(int i=start;i&lt;candidates.size()&amp;&amp;candidates[i]&lt;=target;i++)&#123;
            if(candidates[i]==pre)&#123;
                continue;
            &#125;
            nums.push_back(candidates[i]);
            backtracking(candidates,target-candidates[i],nums,i+1);
            nums.pop_back();
            pre=candidates[i];
        &#125;
    &#125;
&#125;;
</code></pre>
<p>或者使用一个used数组:</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void backtracking(vector&lt;int&gt;&amp; candidates, int target, int sum, int startIndex, vector&lt;bool&gt;&amp; used) &#123;
        if (sum == target) &#123;
            result.push_back(path);
            return;
        &#125;
        for (int i = startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;
            // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 要对同一树层使用过的元素进行跳过
            if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == false) &#123;
                continue;
            &#125;
            sum += candidates[i];
            path.push_back(candidates[i]);
            used[i] = true;
            backtracking(candidates, target, sum, i + 1, used); // 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次
            used[i] = false;
            sum -= candidates[i];
            path.pop_back();
        &#125;
    &#125;

public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;
        vector&lt;bool&gt; used(candidates.size(), false);
        path.clear();
        result.clear();
        // 首先把给candidates排序，让其相同的元素都挨在一起。
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0, used);
        return result;
    &#125;
&#125;;
</code></pre>
<h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p>
<p>回文串 是正着读和反着读都一样的字符串。</p>
<p>示例 1：</p>
<pre><code class="bash">输入：s = &quot;aab&quot;
输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]
</code></pre>
<p>示例 2：</p>
<pre><code class="bash">输入：s = &quot;a&quot;
输出：[[&quot;a&quot;]]
</code></pre>
<p>刚开始判断回文串没转过弯来…</p>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;vector&lt;string&gt;&gt; result;
public:
    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;
        vector&lt;string&gt; path;
        path.clear();
        result.clear();
        backtracking(s,0,path);
        return result;
    &#125;

    void backtracking(const string&amp; s,int start,vector&lt;string&gt;&amp; path)&#123;
        if(start==s.size())&#123;
            result.push_back(path);
            return;
        &#125;
        for(int end=start;end&lt;=s.size();end++)&#123;
            if(judge(s,start,end))&#123;
                string a(s.begin()+start,s.begin()+end+1);
                path.push_back(a);
                backtracking(s,end+1,path);
                path.pop_back();
            &#125;
        &#125;
    &#125;

    bool judge(const string&amp; s,int start,int end)&#123;
        int left=start;
        int right=end;
        while(left&lt;right)&#123;
            if(s[left]!=s[right])&#123;
                return false;
            &#125;
            left++;
            right--;
        &#125;
        return true;
    &#125;
&#125;;
</code></pre>
<p>例子:</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;vector&lt;string&gt;&gt; result;
    vector&lt;string&gt; path; // 放已经回文的子串
    void backtracking (const string&amp; s, int startIndex) &#123;
        // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
        if (startIndex &gt;= s.size()) &#123;
            result.push_back(path);
            return;
        &#125;
        for (int i = startIndex; i &lt; s.size(); i++) &#123;
            if (isPalindrome(s, startIndex, i)) &#123;   // 是回文子串
                // 获取[startIndex,i]在s中的子串
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            &#125; else &#123;                                // 不是回文，跳过
                continue;
            &#125;
            backtracking(s, i + 1); // 寻找i+1为起始位置的子串
            path.pop_back(); // 回溯过程，弹出本次已经填在的子串
        &#125;
    &#125;
    bool isPalindrome(const string&amp; s, int start, int end) &#123;
        for (int i = start, j = end; i &lt; j; i++, j--) &#123;
            if (s[i] != s[j]) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
public:
    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;
        result.clear();
        path.clear();
        backtracking(s, 0);
        return result;
    &#125;
&#125;;
</code></pre>
<p>string有<code>substr</code>函数</p>
<p>优化:<br>上面的代码还存在一定的优化空间, 在于如何更高效的计算一个子字符串是否是回文字串。上述代码isPalindrome函数运用双指针的方法来判定对于一个字符串s, 给定起始下标和终止下标, 截取出的子字符串是否是回文字串。但是其中有一定的重复计算存在:</p>
<p>例如给定字符串”abcde”, 在已知”bcd”不是回文字串时, 不再需要去双指针操作”abcde”而可以直接判定它一定不是回文字串。</p>
<p>具体来说, 给定一个字符串s, 长度为n, 它成为回文字串的充分必要条件是s[0] &#x3D;&#x3D; s[n-1]且s[1:n-1]是回文字串。</p>
<pre><code class="C++">class Solution &#123;
private:
    vector&lt;vector&lt;string&gt;&gt; result;
    vector&lt;string&gt; path; // 放已经回文的子串
    vector&lt;vector&lt;bool&gt;&gt; isPalindrome; // 放事先计算好的是否回文子串的结果
    void backtracking (const string&amp; s, int startIndex) &#123;
        // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
        if (startIndex &gt;= s.size()) &#123;
            result.push_back(path);
            return;
        &#125;
        for (int i = startIndex; i &lt; s.size(); i++) &#123;
            if (isPalindrome[startIndex][i]) &#123;   // 是回文子串
                // 获取[startIndex,i]在s中的子串
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            &#125; else &#123;                                // 不是回文，跳过
                continue;
            &#125;
            backtracking(s, i + 1); // 寻找i+1为起始位置的子串
            path.pop_back(); // 回溯过程，弹出本次已经填在的子串
        &#125;
    &#125;
    void computePalindrome(const string&amp; s) &#123;
        // isPalindrome[i][j] 代表 s[i:j](双边包括)是否是回文字串 
        isPalindrome.resize(s.size(), vector&lt;bool&gt;(s.size(), false)); // 根据字符串s, 刷新布尔矩阵的大小
        for (int i = s.size() - 1; i &gt;= 0; i--) &#123; 
            // 需要倒序计算, 保证在i行时, i+1行已经计算好了
            for (int j = i; j &lt; s.size(); j++) &#123;
                if (j == i) &#123;isPalindrome[i][j] = true;&#125;
                else if (j - i == 1) &#123;isPalindrome[i][j] = (s[i] == s[j]);&#125;
                else &#123;isPalindrome[i][j] = (s[i] == s[j] &amp;&amp; isPalindrome[i+1][j-1]);&#125;
            &#125;
        &#125;
    &#125;
public:
    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;
        result.clear();
        path.clear();
        computePalindrome(s);
        backtracking(s, 0);
        return result;
    &#125;
&#125;;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-23T10:37:26.000Z" itemprop="datePublished">2023-04-23</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-23"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-23/">算法 | day 23</a>
    </header>
    <div class="article-entry post-inner-html">
        
        
        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-23T10:37:06.000Z" itemprop="datePublished">2023-04-23</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-22"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-22/">算法 | day 22</a>
    </header>
    <div class="article-entry post-inner-html">
        
        
        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-23T10:36:34.000Z" itemprop="datePublished">2023-04-23</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-21"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-21/">算法 | day 21</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h2><p>给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。</p>
<p>差值是一个正数，其数值等于两值之差的绝对值。</p>
<p>思路:中序遍历</p>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
private:
    int preValue;
    bool init=false;
    int min=INT_MAX;
public:
    int getMinimumDifference(TreeNode* root) &#123;
        traversal(root);
        return min;
    &#125;

    void traversal(TreeNode* root)&#123;
        if(root==NULL)&#123;
            return;
        &#125;
        traversal(root-&gt;left);
        int value;
        if(!init)&#123;
            init=true;
        &#125;else if((value=root-&gt;val-preValue)&lt;min)&#123;
            min=value;
        &#125;
        preValue=root-&gt;val;
        traversal(root-&gt;right);
    &#125;
&#125;;
</code></pre>
<p>提交的迭代法:</p>
<pre><code class="C++">class Solution &#123;
public:
    int getMinimumDifference(TreeNode* root) &#123;
        stack&lt;TreeNode*&gt; st;
        TreeNode* cur;
        TreeNode* pre=NULL;
        int min=INT_MAX;
        cur=root;
        while(cur!=NULL||!st.empty())&#123;
            if(cur!=NULL)&#123;
                st.push(cur);
                cur=cur-&gt;left;
            &#125;else&#123;
                cur=st.top();
                if(pre!=NULL&amp;&amp;cur-&gt;val-pre-&gt;val&lt;min)&#123;
                    min=cur-&gt;val-pre-&gt;val;
                &#125;
                pre=cur;
                st.pop();
                cur=cur-&gt;right;
            &#125;
        &#125;

        return min;
    &#125;
&#125;;
</code></pre>
<h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p>
<p>如果树中有不止一个众数，可以按 任意顺序 返回。</p>
<p>假定 BST 满足如下定义：</p>
<ul>
<li>结点左子树中所含节点的值 小于等于 当前节点的值</li>
<li>结点右子树中所含节点的值 大于等于 当前节点的值</li>
<li>左子树和右子树都是二叉搜索树</li>
</ul>
<p>思路:使用中序遍历 迭代法…</p>
<p>提交:迭代法</p>
<pre><code class="C++">class Solution &#123;
private:
    
public:
    vector&lt;int&gt; findMode(TreeNode* root) &#123;
        stack&lt;TreeNode*&gt; st;
        vector&lt;int&gt; res;
        TreeNode* cur;
        TreeNode* pre=NULL;
        int maxNum=1;
        int tmp=1;

        cur=root;
        while(cur!=NULL||!st.empty())&#123;
            if(cur!=NULL)&#123;
                st.push(cur);
                cur=cur-&gt;left;
            &#125;else&#123;
                cur=st.top();
                if(pre!=NULL&amp;&amp;cur-&gt;val==pre-&gt;val)&#123;
                    tmp+=1;
                &#125;else if(pre!=NULL)&#123;
                    tmp=1;
                &#125;

                if(tmp==maxNum)&#123;
                    res.push_back(cur-&gt;val);
                &#125;else if(tmp&gt;maxNum)&#123;
                    maxNum=tmp;
                    res.clear();
                    res.push_back(cur-&gt;val);
                &#125;

                pre=cur;
                st.pop();
                cur=cur-&gt;right;
            &#125;
        &#125;

        return res;
    &#125;
&#125;;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-23T10:35:31.000Z" itemprop="datePublished">2023-04-23</time>
</div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-算法-day-20"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-20/">算法 | day 20</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:</p>
<p>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。</p>
<p>思路:暴力找出最大值,但是多了重复的遍历</p>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;
        if(nums.empty())&#123;
            return NULL;
        &#125;
        return construct(nums,0,nums.size()-1);
    &#125;

    TreeNode* construct(vector&lt;int&gt;&amp; nums,int start,int end)&#123;
        if(end&lt;start)&#123;
            return NULL;
        &#125;
        int max=INT_MIN;
        int k=start;
        for(int i=start;i&lt;=end;i++)&#123;
            if(nums[i]&gt;max)&#123;
                max=nums[i];
                k=i;
            &#125;
        &#125;
        TreeNode* node=new TreeNode(max);
        node-&gt;left=construct(nums,start,k-1);
        node-&gt;right=construct(nums,k+1,end);
        return node;
    &#125;
&#125;;
</code></pre>
<p>方法:单调栈</p>
<p>在最终构造出的树上，以 nums[i]为根节点的子树，在原数组中对应的区间，左边界为 nums[i]左侧第一个比它大的元素所在的位置，右边界为 nums[i]右侧第一个比它大的元素所在的位置。左右边界均为开边界。</p>
<p>如果某一侧边界不存在，则那一侧边界为数组的边界。如果两侧边界均不存在，说明其为最大值，即根节点。</p>
<p>并且：nums[i]的父结点是两个边界中较小的那个元素对应的节点。</p>
<p>因此，我们的任务变为：找出每一个元素左侧和右侧第一个比它大的元素所在的位置。这就是一个经典的单调栈问题了。</p>
<p>代码:</p>
<pre><code class="C++">class Solution &#123;
public:
    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;
        int n = nums.size();
        vector&lt;int&gt; stk;
        vector&lt;int&gt; left(n, -1), right(n, -1);
        vector&lt;TreeNode*&gt; tree(n);
        for (int i = 0; i &lt; n; ++i) &#123;
            tree[i] = new TreeNode(nums[i]);
            while (!stk.empty() &amp;&amp; nums[i] &gt; nums[stk.back()]) &#123;
                right[stk.back()] = i;
                stk.pop_back();
            &#125;
            if (!stk.empty()) &#123;
                left[i] = stk.back();
            &#125;
            stk.push_back(i);
        &#125;

        TreeNode* root = nullptr;
        for (int i = 0; i &lt; n; ++i) &#123;
            if (left[i] == -1 &amp;&amp; right[i] == -1) &#123;
                root = tree[i];
            &#125;
            else if (right[i] == -1 || (left[i] != -1 &amp;&amp; nums[left[i]] &lt; nums[right[i]])) &#123;
                tree[left[i]]-&gt;right = tree[i];
            &#125;
            else &#123;
                tree[right[i]]-&gt;left = tree[i];
            &#125;
        &#125;
        return root;
    &#125;
&#125;;
</code></pre>
<p>我们还可以把最后构造树的过程放进单调栈求解的步骤中，省去用来存储左右边界的数组。</p>
<pre><code class="C++">class Solution &#123;
public:
    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;
        int n = nums.size();
        vector&lt;int&gt; stk;
        vector&lt;TreeNode*&gt; tree(n);
        for (int i = 0; i &lt; n; ++i) &#123;
            tree[i] = new TreeNode(nums[i]);
            while (!stk.empty() &amp;&amp; nums[i] &gt; nums[stk.back()]) &#123;
                tree[i]-&gt;left = tree[stk.back()];
                stk.pop_back();
            &#125;
            if (!stk.empty()) &#123;
                tree[stk.back()]-&gt;right = tree[i];
            &#125;
            stk.push_back(i);
        &#125;
        return tree[stk[0]];
    &#125;
&#125;;
</code></pre>
<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><p>给你两棵二叉树： root1 和 root2 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p>注意: 合并过程必须从两个树的根节点开始。</p>
<p>思路:递归</p>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;
        if(root1==NULL)&#123;
            return root2;
        &#125;else if(root2==NULL)&#123;
            return root1;
        &#125;
        root1-&gt;val+=root2-&gt;val;
        root1-&gt;left=mergeTrees(root1-&gt;left,root2-&gt;left);
        root1-&gt;right=mergeTrees(root1-&gt;right,root2-&gt;right);
        return root1;
    &#125;
&#125;;
</code></pre>
<p>迭代法,使用队列(层序遍历):</p>
<pre><code class="C++">class Solution &#123;
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123;
        if (t1 == NULL) return t2;
        if (t2 == NULL) return t1;
        queue&lt;TreeNode*&gt; que;
        que.push(t1);
        que.push(t2);
        while(!que.empty()) &#123;
            TreeNode* node1 = que.front(); que.pop();
            TreeNode* node2 = que.front(); que.pop();
            // 此时两个节点一定不为空，val相加
            node1-&gt;val += node2-&gt;val;

            // 如果两棵树左节点都不为空，加入队列
            if (node1-&gt;left != NULL &amp;&amp; node2-&gt;left != NULL) &#123;
                que.push(node1-&gt;left);
                que.push(node2-&gt;left);
            &#125;
            // 如果两棵树右节点都不为空，加入队列
            if (node1-&gt;right != NULL &amp;&amp; node2-&gt;right != NULL) &#123;
                que.push(node1-&gt;right);
                que.push(node2-&gt;right);
            &#125;

            // 当t1的左节点 为空 t2左节点不为空，就赋值过去
            if (node1-&gt;left == NULL &amp;&amp; node2-&gt;left != NULL) &#123;
                node1-&gt;left = node2-&gt;left;
            &#125;
            // 当t1的右节点 为空 t2右节点不为空，就赋值过去
            if (node1-&gt;right == NULL &amp;&amp; node2-&gt;right != NULL) &#123;
                node1-&gt;right = node2-&gt;right;
            &#125;
        &#125;
        return t1;
    &#125;
&#125;;
</code></pre>
<h2 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h2><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p>
<p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。</p>
<p>思路:二叉搜索树用中序遍历</p>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    TreeNode* searchBST(TreeNode* root, int val) &#123;
        if(!root)&#123;
            return NULL;
        &#125;
        if(root-&gt;val==val)&#123;
            return root;
        &#125;else if(root-&gt;val&gt;val)&#123;
            return searchBST(root-&gt;left, val);
        &#125;else&#123;
            return searchBST(root-&gt;right, val);
        &#125;
    &#125;
&#125;;
</code></pre>
<p>迭代法:</p>
<pre><code class="C++">class Solution &#123;
public:
    TreeNode* searchBST(TreeNode* root, int val) &#123;
        while (root != NULL) &#123;
            if (root-&gt;val &gt; val) root = root-&gt;left;
            else if (root-&gt;val &lt; val) root = root-&gt;right;
            else return root;
        &#125;
        return NULL;
    &#125;
&#125;;
</code></pre>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 小于 当前节点的数。</li>
<li>节点的右子树只包含 大于 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p>思路:中序遍历</p>
<pre><code class="C++">class Solution &#123;
private:
    int curVal;
    int init=false;
public:
    bool isValidBST(TreeNode* root) &#123;
        if(root==NULL)&#123;
            return true;
        &#125;
        bool b1=isValidBST(root-&gt;left);
        if(!init)&#123;
            curVal=root-&gt;val;
            init=true;
        &#125;else if(root-&gt;val&lt;=curVal)&#123;
            return false;
        &#125;
        curVal=root-&gt;val;
        bool b2=isValidBST(root-&gt;right);
        return b1&amp;&amp;b2;
    &#125;
&#125;;
</code></pre>
<p>可以把上述代码中的curVal改为TreeNode节点,这样就不需要判断是否初始化:</p>
<pre><code class="C++">class Solution &#123;
public:
    TreeNode* pre = NULL; // 用来记录前一个节点
    bool isValidBST(TreeNode* root) &#123;
        if (root == NULL) return true;
        bool left = isValidBST(root-&gt;left);

        if (pre != NULL &amp;&amp; pre-&gt;val &gt;= root-&gt;val) return false;
        pre = root; // 记录前一个节点

        bool right = isValidBST(root-&gt;right);
        return left &amp;&amp; right;
    &#125;
&#125;;
</code></pre>
<p>也可以用迭代法,在二叉树的中序遍历基础上修改一下:</p>
<pre><code class="C++">class Solution &#123;
public:
    bool isValidBST(TreeNode* root) &#123;
        stack&lt;TreeNode*&gt; st;
        TreeNode* cur = root;
        TreeNode* pre = NULL; // 记录前一个节点
        while (cur != NULL || !st.empty()) &#123;
            if (cur != NULL) &#123;
                st.push(cur);
                cur = cur-&gt;left;                // 左
            &#125; else &#123;
                cur = st.top();                 // 中
                st.pop();
                if (pre != NULL &amp;&amp; cur-&gt;val &lt;= pre-&gt;val)
                return false;
                pre = cur; //保存前一个访问的结点

                cur = cur-&gt;right;               // 右
            &#125;
        &#125;
        return true;
    &#125;
&#125;;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2023-04-23T10:34:22.000Z" itemprop="datePublished">2023-04-23</time>
</div>
    
    
    </div>
</footer>

</article>

    
  

  
    <nav class="pagination">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next</a>
    </nav>
  
</div>

                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
    
      

    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-34/">算法 | day 34</a>
          </li>
        
          <li>
            <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-32/">算法 | day 32</a>
          </li>
        
          <li>
            <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-31/">算法 | day 31</a>
          </li>
        
          <li>
            <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-30/">算法 | day 30</a>
          </li>
        
          <li>
            <a href="/2023/04/23/%E7%AE%97%E6%B3%95-day-28/">算法 | day 28</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            Hexo &copy; 2023<br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>

<script type="module" src="https://unpkg.com/ionicons@6.0.2/dist/ionicons/ionicons.esm.js"></script>






<script src="/dist/build.js?1654266144177.js"></script>


<script src="/dist/custom.js?1654266144177.js"></script>













</body>

</html>