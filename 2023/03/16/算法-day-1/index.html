<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>算法 | day 1 | Hexo</title>

    <meta name="description" content="Hexo">
    <meta name="keywords" content="">

    

    <meta property="og:locale" content="cn" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content= "算法 | day 1 | Hexo"  />
    <meta property="og:description" content= "Hexo" />
    <meta property="og:url" content="http://example.com/2023/03/16/%E7%AE%97%E6%B3%95-day-1/index.html" />
    <meta property="og:site_name" content="" />
    <meta property="article:author" content="John Doe" />
    <meta property="article:publisher" content="" />
    <meta property="og:description" content="Hexo" />
    <meta name="twitter:title" content="算法 | day 1 | Hexo"/>
    <meta name="twitter:description" content="Hexo"/>
    <script type="application/ld+json">
        {
            "description": "Hexo",
            "author": { "@type": "Person", "name": "John Doe" },
            "@type": "BlogPosting",
            "url": "http://example.com/2023/03/16/%E7%AE%97%E6%B3%95-day-1/index.html",
            "publisher": {
            "@type": "Organization",
            "logo": {
                "@type": "ImageObject",
                "url": "http://example.com/images/avatar.jpg"
            },
            "name": "John Doe"
            },
            "headline": "算法 | day 1 | Hexo",
            "datePublished": "2023-03-16T10:07:27.000Z",
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "http://example.com/2023/03/16/%E7%AE%97%E6%B3%95-day-1/index.html"
            },
            "@context": "http://schema.org"
        }
    </script>




    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1654266144177.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1654266144177.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/avatar.jpg" alt="John Doe">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>Hexo</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-clfaygy6q00005ouh6mww18k2" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      算法 | day 1
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2023-03-16T10:07:27.000Z" itemprop="datePublished">2023-03-16</time>
</div>

            

            
            <div class="article-tag">
                <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
            </div>
            

            

        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <blockquote>
<p>本文参考自 <a target="_blank" rel="noopener" href="https://programmercarl.com/">代码随想录</a></p>
</blockquote>
<h2 id="数组基础"><a href="#数组基础" class="headerlink" title="数组基础"></a>数组基础</h2><p>数组是存放在连续内存空间上的相同类型数据的集合</p>
<p>需要两点注意的是:</p>
<ul>
<li>数组下标都是从0开始的</li>
<li>数组内存空间的地址是连续的</li>
</ul>
<p><strong>因为数组的在内存空间的地址是连续的,所以我们在删除或者增添元素的时候,就难免要移动其他元素的地址.数组的元素是不能删的,只能覆盖.</strong></p>
<p>在C++中二维数组是连续分布的</p>
<p>测试:</p>
<pre><code class="c++">void test_arr() &#123;
    int array[2][3] = &#123;
        &#123;0, 1, 2&#125;,
        &#123;3, 4, 5&#125;
    &#125;;
    cout &lt;&lt; &amp;array[0][0] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[0][1] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[0][2] &lt;&lt; endl;
    cout &lt;&lt; &amp;array[1][0] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[1][1] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[1][2] &lt;&lt; endl;
&#125;

int main() &#123;
    test_arr();
&#125;
</code></pre>
<p>结果:</p>
<pre><code>0x20d4dffc90 0x20d4dffc94 0x20d4dffc98
0x20d4dffc9c 0x20d4dffca0 0x20d4dffca4
</code></pre>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target,写一个函数搜索 nums 中的 target,如果目标值存在返回下标,否则返回 -1</p>
<p>示例 1:</p>
<pre><code class="bash">输入: nums = [-1,0,3,5,9,12], target = 9     
输出: 4       
解释: 9 出现在 nums 中并且下标为 4     
</code></pre>
<p>示例 2:</p>
<pre><code class="bash">输入: nums = [-1,0,3,5,9,12], target = 2     
输出: -1        
解释: 2 不存在 nums 中因此返回 -1     
</code></pre>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    int search(vector&lt;int&gt;&amp; nums, int target) &#123;
        int low=0;
        int high=nums.size()-1;
        while(high&gt;=low)&#123;
            int mid=low+(high-low)/2;
            if(nums[mid]&gt;target)&#123;
                high=mid-1;
            &#125;else if(nums[mid]&lt;target)&#123;
                low=mid+1;
            &#125;else&#123;
                return mid;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;
</code></pre>
<p>这道题目的前提是数组为有序数组,同时题目还强调数组中无重复元素,因为一旦有重复元素,使用二分查找法返回的元素下标可能不是唯一的.</p>
<p>二分查找涉及的很多的边界条件,逻辑比较简单.但较容易分不清到底是 while(left &lt; right) 还是 while(left &lt;&#x3D; right),到底是right &#x3D; middle呢,还是要right &#x3D; middle - 1.</p>
<p>写二分法,区间的定义一般为两种,左闭右闭即[left, right],或者左闭右开即[left, right).</p>
<p>例子如下:</p>
<pre><code class="C++">// 版本一
class Solution &#123;
public:
    int search(vector&lt;int&gt;&amp; nums, int target) &#123;
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里,[left, right]
        while (left &lt;= right) &#123; // 当left==right,区间[left, right]依然有效,所以用 &lt;=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] &gt; target) &#123;
                right = middle - 1; // target 在左区间,所以[left, middle - 1]
            &#125; else if (nums[middle] &lt; target) &#123;
                left = middle + 1; // target 在右区间,所以[middle + 1, right]
            &#125; else &#123; // nums[middle] == target
                return middle; // 数组中找到目标值,直接返回下标
            &#125;
        &#125;
        // 未找到目标值
        return -1;
    &#125;
&#125;;
</code></pre>
<pre><code class="C++">// 版本二
class Solution &#123;
public:
    int search(vector&lt;int&gt;&amp; nums, int target) &#123;
        int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里,即:[left, right)
        while (left &lt; right) &#123; // 因为left == right的时候,在[left, right)是无效的空间,所以使用 &lt;
            int middle = left + ((right - left) &gt;&gt; 1);
            if (nums[middle] &gt; target) &#123;
                right = middle; // target 在左区间,在[left, middle)中
            &#125; else if (nums[middle] &lt; target) &#123;
                left = middle + 1; // target 在右区间,在[middle + 1, right)中
            &#125; else &#123; // nums[middle] == target
                return middle; // 数组中找到目标值,直接返回下标
            &#125;
        &#125;
        // 未找到目标值
        return -1;
    &#125;
&#125;;
</code></pre>
<h2 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h2><p>给定一个排序数组和一个目标值,在数组中找到目标值,并返回其索引.如果目标值不存在于数组中,返回它将会被按顺序插入的位置.</p>
<p>你可以假设数组中无重复元素.</p>
<p>示例 1:</p>
<ul>
<li><p>输入: [1,3,5,6], 5</p>
</li>
<li><p>输出: 2</p>
</li>
<li><p>示例 2:</p>
</li>
<li><p>输入: [1,3,5,6], 2</p>
</li>
<li><p>输出: 1</p>
</li>
</ul>
<p>示例 3:</p>
<ul>
<li>输入: [1,3,5,6], 7</li>
<li>输出: 4</li>
</ul>
<p>示例 4:</p>
<ul>
<li>输入: [1,3,5,6], 0</li>
<li>输出: 0</li>
</ul>
<p><font color="red">未提交</font></p>
<p>这题target插入有四种情况:</p>
<ul>
<li>target在数组所有元素之前</li>
<li>target等于数组中某一个元素</li>
<li>target插入数组中的位置</li>
<li>target在数组所有元素之后</li>
</ul>
<p>二分查找(左闭右闭区间)如果一直没找到相等值,最终一定会 <code>low=high-1</code> -&gt; <code>low=high</code></p>
<p>当<code>low=high</code>时</p>
<ul>
<li><code>target&lt;nums[mid]</code> -&gt; <code>high=mid-1</code>,即<code>high=low-1</code>,返回low、high+1</li>
<li><code>target&gt;nums[mid]</code> -&gt; <code>low=mid+1</code> ,即<code>low=high+1</code>,返回low、high+1</li>
</ul>
<p>例子:</p>
<pre><code class="C++">class Solution &#123;
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;
        int n = nums.size();
        int left = 0;
        int right = n - 1; // 定义target在左闭右闭的区间里,[left, right]
        while (left &lt;= right) &#123; // 当left==right,区间[left, right]依然有效
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] &gt; target) &#123;
                right = middle - 1; // target 在左区间,所以[left, middle - 1]
            &#125; else if (nums[middle] &lt; target) &#123;
                left = middle + 1; // target 在右区间,所以[middle + 1, right]
            &#125; else &#123; // nums[middle] == target
                return middle;
            &#125;
        &#125;
        // 分别处理如下四种情况
        // 目标值在数组所有元素之前  [0, -1]
        // 目标值等于数组中某一个元素  return middle;
        // 目标值插入数组中的位置 [left, right],return  right + 1
        // 目标值在数组所有元素之后的情况 [left, right], 因为是右闭区间,所以 return right + 1
        return right + 1;
    &#125;
&#125;;
</code></pre>
<pre><code class="C++">class Solution &#123;
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;
        int n = nums.size();
        int left = 0;
        int right = n; // 定义target在左闭右开的区间里,[left, right)  target
        while (left &lt; right) &#123; // 因为left == right的时候,在[left, right)是无效的空间
            int middle = left + ((right - left) &gt;&gt; 1);
            if (nums[middle] &gt; target) &#123;
                right = middle; // target 在左区间,在[left, middle)中
            &#125; else if (nums[middle] &lt; target) &#123;
                left = middle + 1; // target 在右区间,在 [middle+1, right)中
            &#125; else &#123; // nums[middle] == target
                return middle; // 数组中找到目标值的情况,直接返回下标
            &#125;
        &#125;
        // 分别处理如下四种情况
        // 目标值在数组所有元素之前 [0,0)
        // 目标值等于数组中某一个元素 return middle
        // 目标值插入数组中的位置 [left, right) ,return right 即可
        // 目标值在数组所有元素之后的情况 [left, right),因为是右开区间,所以 return right
        return right;
    &#125;
&#125;;
</code></pre>
<h2 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h2><p>给你一个按照非递减顺序排列的整数数组 nums,和一个目标值 target.请你找出给定目标值在数组中的开始位置和结束位置.</p>
<p>如果数组中不存在目标值 target,返回 [-1, -1].</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题.</p>
<p>示例 1:</p>
<pre><code class="bash">输入:nums = [5,7,7,8,8,10], target = 8
输出:[3,4]
</code></pre>
<p>示例 2:</p>
<pre><code class="bash">输入:nums = [5,7,7,8,8,10], target = 6
输出:[-1,-1]
</code></pre>
<p>示例 3:</p>
<pre><code class="bash">输入:nums = [], target = 0
输出:[-1,-1]
</code></pre>
<p>提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;
        int low=0;
        int high=nums.size()-1;
        int mid=search(nums,target,low,high);
        if(mid==-1)&#123;
            return &#123;-1,-1&#125;;
        &#125;
        int right=mid,left=mid;
        //注意可以在循环括号中赋值并判断,但不能初始化(重复初始化)
        //重复计算,每次二分查找low都为0
        while((mid=search(nums,target,low,left-1))!=-1)&#123;
            left=mid;
        &#125;
        while((mid=search(nums,target,right + 1, high))!=-1)&#123;
            right=mid;
        &#125;
        return &#123;left,right&#125;;
    &#125;

    int search(vector&lt;int&gt;&amp; nums, int target,int low,int high) &#123;
        while(high&gt;=low)&#123;
            int mid=low+(high-low)/2;
            if(nums[mid]&gt;target)&#123;
                high=mid-1;
            &#125;else if(nums[mid]&lt;target)&#123;
                low=mid+1;
            &#125;else&#123;
                return mid;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;
</code></pre>
<p>思路先做一次二分查找,再不断向左向右二分查找,直到找不到值.</p>
<p><font color="red">但是代码有重复计算,每次二分查找都是low&#x3D;0或者high&#x3D;nums.size()-1,实际上,在循环过程中,因为上次循环计算过low和high,下次循环应该从上次计算的边界开始.</font></p>
<p><font color="red">leetcode优质回答:</font></p>
<pre><code class="C++">class Solution &#123;
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;
        return &#123;find(nums, target, true), find(nums, target, false)&#125;;
    &#125;

    int find(vector&lt;int&gt; nums, int target, bool minType) &#123;
        int left = 0, right = nums.size() - 1;
        int ans = -1;
        while (left &lt;= right) &#123;
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) &#123;
                //只有在相等的时候才更新边界!
                ans = mid;
                if (minType) &#123;
                    right = mid - 1;
                &#125; else &#123;
                    left = mid + 1;
                &#125;
            &#125; else if (target &lt; nums[mid]) &#123;
                right = mid - 1;
            &#125; else &#123;
                left = mid + 1;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
<p>寻找target在数组里的左右边界,有如下三种情况:</p>
<ul>
<li><p>情况一:target 在数组范围的右边或者左边,例如数组{3, 4, 5},target为2或者数组{3, 4, 5},target为6,此时应该返回{-1, -1}</p>
</li>
<li><p>情况二:target 在数组范围中,且数组中不存在target,例如数组{3,6,7},target为5,此时应该返回{-1, -1}</p>
</li>
<li><p>情况三:target 在数组范围中,且数组中存在target,例如数组{3,6,7},target为6,此时应该返回{1, 1}</p>
</li>
</ul>
<p>示例代码:</p>
<pre><code class="C++">class Solution &#123;
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;
        int leftBorder = getLeftBorder(nums, target);
        int rightBorder = getRightBorder(nums, target);
        // 情况一
        if (leftBorder == -2 || rightBorder == -2) return &#123;-1, -1&#125;;
        // 情况三
        if (rightBorder - leftBorder &gt; 1) return &#123;leftBorder + 1, rightBorder - 1&#125;;
        // 情况二
        return &#123;-1, -1&#125;;
    &#125;
private:
     int getRightBorder(vector&lt;int&gt;&amp; nums, int target) &#123;
        int left = 0;
        int right = nums.size() - 1;
        int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况
        while (left &lt;= right) &#123;
            int middle = left + ((right - left) / 2);
            if (nums[middle] &gt; target) &#123;
                right = middle - 1;
            &#125; else &#123; // 寻找右边界,nums[middle] == target的时候更新left
                left = middle + 1;
                rightBorder = left;
            &#125;
        &#125;
        return rightBorder;
    &#125;
    int getLeftBorder(vector&lt;int&gt;&amp; nums, int target) &#123;
        int left = 0;
        int right = nums.size() - 1;
        int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况
        while (left &lt;= right) &#123;
            int middle = left + ((right - left) / 2);
            if (nums[middle] &gt;= target) &#123; // 寻找左边界,nums[middle] == target的时候更新right
                right = middle - 1;
                leftBorder = right;
            &#125; else &#123;
                left = middle + 1;
            &#125;
        &#125;
        return leftBorder;
    &#125;
&#125;;
</code></pre>
<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>给你一个数组 nums 和一个值 val,你需要 原地 移除所有数值等于 val 的元素,并返回移除后数组的新长度.</p>
<p>不要使用额外的数组空间,你必须仅使用 O(1) 额外空间并原地修改输入数组.</p>
<p>元素的顺序可以改变.你不需要考虑数组中超出新长度后面的元素.</p>
<p>示例 1: 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2. 你不需要考虑数组中超出新长度后面的元素.</p>
<p>示例 2: 给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4.</p>
<p>你不需要考虑数组中超出新长度后面的元素.</p>
<p>leetcode提交:</p>
<pre><code class="C++">class Solution &#123;
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;
        if(nums.size()==0)&#123;
            return 0;
        &#125;
        int slow=0,fast=0;
        while(slow&lt;nums.size()&amp;&amp;nums[slow]!=val)&#123;
            slow++;
            fast++;
        &#125;
        for(;fast&lt;nums.size();fast++)&#123;
            if(nums[fast]==val)&#123;
                continue;
            &#125;else&#123;
                nums[slow]=nums[fast];
                slow++;
            &#125;
        &#125;
        return slow;
    &#125;
&#125;;
</code></pre>
<p>例子:</p>
<pre><code class="C++">class Solution &#123;
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex &lt; nums.size(); fastIndex++) &#123;
            if (val != nums[fastIndex]) &#123;
                nums[slowIndex++] = nums[fastIndex];
            &#125;
        &#125;
        return slowIndex;
    &#125;
&#125;;
</code></pre>

        </div>

    </div>

    

    

    

    

    

    
<nav class="article-nav">
  
    <a href="/2023/03/17/SNPE-Snapdragon%E7%A5%9E%E7%BB%8F%E5%A4%84%E7%90%86%E5%BC%95%E6%93%8E%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%20/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">下一篇</div>
      <div class="article-nav-title">
        
          SNPE-Snapdragon神经处理引擎环境配置
        
      </div>
    </a>
  
  
    <a href="/2023/03/16/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">上一篇</div>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://twitter.com/share?text=算法 | day 1 - Hexo&url=http%3A%2F%2Fexample.com%2F2023%2F03%2F16%2F%25E7%25AE%2597%25E6%25B3%2595-day-1%2F">
            <ion-icon name="logo-twitter"></ion-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://www.facebook.com/sharer.php?title=算法 | day 1 - Hexo&u=http%3A%2F%2Fexample.com%2F2023%2F03%2F16%2F%25E7%25AE%2597%25E6%25B3%2595-day-1%2F">
            <ion-icon name="logo-facebook"></ion-icon>
        </a>
        <!-- <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=算法 | day 1 - Hexo&url=http://example.com/2023/03/16/%E7%AE%97%E6%B3%95-day-1/&pic=">
            <div class="n-icon n-icon-weibo"></div>
        </a> -->
    </section>

</article>
















</div>
                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      

    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2023/03/22/%E7%AE%97%E6%B3%95-day-4/">算法 | day 4</a>
          </li>
        
          <li>
            <a href="/2023/03/21/%E7%AE%97%E6%B3%95-day-3/">算法 | day 3</a>
          </li>
        
          <li>
            <a href="/2023/03/20/%E7%AE%97%E6%B3%95-day-2/">算法 | day 2</a>
          </li>
        
          <li>
            <a href="/2023/03/17/SNPE-Snapdragon%E7%A5%9E%E7%BB%8F%E5%A4%84%E7%90%86%E5%BC%95%E6%93%8E%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%20/">SNPE-Snapdragon神经处理引擎环境配置</a>
          </li>
        
          <li>
            <a href="/2023/03/16/%E7%AE%97%E6%B3%95-day-1/">算法 | day 1</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            Hexo &copy; 2023<br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>

<script type="module" src="https://unpkg.com/ionicons@6.0.2/dist/ionicons/ionicons.esm.js"></script>






<script src="/dist/build.js?1654266144177.js"></script>


<script src="/dist/custom.js?1654266144177.js"></script>













</body>

</html>